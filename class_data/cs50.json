{
    "class": "cs50",
    "lectures": [
        {
            "lecture": 10,
            "content": "Cybersecurity\nRecap\nLooking Ahead\nCybersecurity\nPasswords\nPhone Security\nPassword Managers\nTwo-factor Authentication\nHashing\nCryptography\nPasskeys\nEncryption\nDeletion\nSumming Up\nRecap\nOver these past ten weeks, you have been drinking from the proverbial firehose.\nWhile in this course, you learned how to program many programming languages; indeed, our great hope is that you learned how to program in all: Regardless of the programming language.\nFurther, we hope that you learned how to solve problems above all else.\nLooking Ahead\nAs you journey from the work of this course to the world outside CS50, you may want to take a number of steps to prepare.\nTo be able to execute commands on the terminal, much like you did on CS50.dev, you can install command-line tools on your Mac or PC.\nYou can learn more about Git.\nYou can download and learn about VS Code.\nYou can host a website using GitHub or Netlify.\nYou can host a web app using AWS, Azure, or Google Cloud.\nYou can ask questions in relevant online communities.\nYou can ask questions using AI-based tools like OpenAI and GitHub Copilot.\nYou can take any of our other CS50 courses.\nYou can join one of our many communities.\nCybersecurity\nToday will be a high-level overview of some of the cybersecurity-related topics.\nCybersecurity is understanding how our data is secure or not secure.\nPasswords\nOne cybersecurity concern relates to our passwords.\nPasswords are one method used to secure data online.\nThere are common passwords that people use:\n\n1. 123456\n2. admin\n3. 12345678\n4. 123456789\n5. 1234\n6. 12345\n7. password\n8. 123\n9. Aa123456\n10. 1234567890\nIf you have one of the passwords above, most likely, millions of people have the same password as you!\nAdversaries in the world will start with this list.\nBad guys can also guess most of the heuristics you use to add symbols to your password.\nAdversaries can use brute-force attacks, using a dictionary of passwords to simply try every possible password.\nYour password is likely not as secure as you think it is.\nPhone Security\nMany phones are secured by a four-digit code.\nThe most simple form of attack would be to brute-force attempt all possible passwords.\nThere are 10,000 possible passwords when using a four-digit code.\nIf it takes one guess per second, it will take 10,000 seconds to crack the password.\nHowever, if a programmer creates a program to generate all possible codes, the time required would be minimal. Consider the following code in Python:\n\nfrom string import digits\nfrom itertools import product\n\nfor passcode in product(digits, repeat=4):\n    print(passcode)\nIt should be quite disconcerting that the code above could take only a few seconds (at most!) to discover your password.\nWe could improve our security by switching to a four-letter password. This would result in 7,311,616 possible passwords.\nIncluding uppercase and lowercase characters would create over 78 million possibilities.\nConsider how we could modify your code to discover these passwords:\n\nfrom string import ascii_letters\nfrom itertools import product\n\nfor passcode in product(ascii_letters, repeat=4):\n    print(passcode)\nWe could even add the ability to look at all possible eight-digit passwords with letters, numbers, and punctuations:\n\nfrom string import ascii_letters, digits, punctuation\nfrom itertools import product\n\nfor passcode in product(ascii_letters + digits + punctuation, repeat=8):\n    print(passcode)\nExpanding to eight characters, including upper and lowercase letters, numbers, and symbols, would result in 6,095,689,385,410,816 possible combinations.\nIn the digital world, you simply want your password to be better than other peoples\u2019 passwords such that others would be attacked far before you\u2014as you are a much less convenient target.\nA downside of using such a long password is the downside of having to remember it.\nAccordingly, there are other defenses that could be employed to slow down an attacker. For example, some phone manufacturers lock out those who guess a password incorrectly.\nSecurity is about finding a \u201csweet spot\u201d between the trade-offs of enhanced security while maintaining convenience.\nPassword Managers\nPassword managers can be used to create very challenging passwords and remember them for you.\nThe probability of a password secured by a password manager being broken is very, very low.\nYou\u2019d hope that such password managers are secure. However, if one gains access to your password manager, they would have access to all your passwords.\nIn the end, you are far less likely to be at risk by those you live with\u2014and much more likely to be at risk by the billions of other people on the internet.\nAs mentioned prior, you can make a decision based on a balance between security and convenience.\nTwo-factor Authentication\nAdding another means by which you must authenticate adds further security. However, there is a human cost as you might not have access to your second factor.\nThese are implemented as one-time passwords of sorts that are sent to an email, device, or phone number.\nAlways, security policies attempt to balance the needs of security and human convenience.\nHashing\nYour account information and other sensitive data should not be stored as raw text in an online database.\nIf a database becomes compromised and all credentials are stored in plain text, credentials for other services at other websites are likely also compromised.\nHence, hashing algorithms, as discussed earlier in this course, are used to store only hashed values of passwords.\nOne-way hashing allows online services to actually never store the original password typed by the user: Only the hashed value of these passwords. Accordingly, if there is a breach, only the hashed value will be known.\nRainbow tables are huge dictionaries that adversaries use to attempt to pre-hash possible passwords as a means by which to attempt to break the hash algorithm.\nAs an additional process to heightened security, programmers may sometimes introduce salting where it becomes unlikely that multiple users may have the same hash value to represent their passwords. You can imagine this as follows:\n\nsalt and password being fed to an algorithm outputting a hash\n\nCryptography\nSimilar to hashing, a cipher algorithm can use a public key and text to create ciphertext.\nIn turn, a private key and the ciphertext can be fed to the algorithm to decrypt the text.\nPasskeys\nPasskeys are a new technology only emerging in the most recent months.\nThrough private keys and a challenge being fed to an algorithm, websites can authenticate you through the unique signature created by your device.\n\npublic key and challenge being provided to an alogirthm resulting in a signature\n\nHence, passwords and usernames may soon become obsolete.\nEncryption\nEncryption is a way by which data is obscured such that only the sender and intended receiver can be read.\nEarly in this course, we learned a very simple algorithm to \u201cshift\u201d the text by one or more characters as a rudimentary form of encryption.\nEnd-to-end encryption is a way by which encrypting and decrypting happen on the same system without a middleman. This prevents the middleman or a malicious actor from being able to snoop on your data. Zoom and Apple Messages can both utilize end-to-end encryption.\nDeletion\nTrashing a file on your computer or emptying the trash can does not actually delete the actual bits of the file on your computer.\nInstead, remnants of the files are left.\n\nremnants of a file on a hard drive\n\nSecure deletion is where the remnants of those files are turned into zeros and ones.\nStill, some remnants may remain because of what is rendered inaccessible by the operating system.\nFull-disk encryption allows your entire hard drive to be encrypted. Thus, your deleted files are less accessible to adversaries.\nConsidering encryption, it\u2019s this same technology that adversaries use to create ransomware that can, quite literally, hold your hard drive for ransom.\nSumming Up\nUse a password manager.\nUse two-factor authentication.\nUse (end-to-end) encryption."
        },
        {
            "lecture": 3,
            "content": "Lecture 3\nWelcome!\nLinear Search\nBinary Search\nRunning Time\nsearch.c\nData Structures\nSorting\nBubble Sort\nRecursion\nMerge Sort\nSumming Up\nWelcome!\nIn week zero, we introduced the idea of an algorithm: a black box that may take an input and creates an output.\nThis week, we are going to expand upon our understanding of algorithms through pseudocode and into code itself.\nAlso, we are going to consider the efficiency of these algorithms. Indeed, we are going to be building upon our understanding of how to use some of the lower-level concepts we discussed last week in building algorithms.\nRecall back to earlier in the course when we introduced the following graph:\n\nchart with: \"size of problem\" as x-axis; \"time to solve\" as y-axis; red, steep straight line from origin to top of graph close to yellow, less steep straight line from origin to top of graph both labeled \"n\"; green, curved line that gets less and less steep from origin to right of graph labeled \"log n)\n\nAs we step into this week, you should consider how the way an algorithm works with a problem may determine the time it takes to solve a problem! Algorithms can be designed to be more and more efficient, to a limit.\nToday, we will focus upon the design of algorithms and how to measure their efficiency.\nLinear Search\nRecall that last week you were introduced to the idea of an array, blocks of memory that are consecutive: side-by-side with one another.\nYou can metaphorically imagine an array like a series of seven red lockers as follows:\n\nSeven red lockers side by side\n\nWe can imagine that we have an essential problem of wanting to know, \u201cIs the number 50 inside an array?\u201d A computer must look at each locker to be able to see if the number 50 is inside. We call this process of finding such a number, character, string, or other item searching.\nWe can potentially hand our array to an algorithm, wherein our algorithm will search through our lockers to see if the number 50 is behind one of the doors: Returning the value true or false.\n\nseven red lockers pointing to an empty box. Out of the empty box comes and output of bool\n\nWe can imagine various instructions we might provide our algorithm to undertake this task as follows:\n\nFor each door from left to right\n    If 50 is behind door\n        Return true\nReturn false\nNotice that the above instructions are called pseudocode: A human-readable version of the instructions that we could provide the computer.\n\nA computer scientist could translate that pseudocode as follows:\n\nFor i from 0 to n-1\n    If 50 is behind doors[i]\n        Return true\nReturn false\nNotice that the above is still not code, but it is a pretty close approximation of what the final code might look like.\n\nBinary Search\nBinary search is another search algorithm that could be employed in our task of finding the 50.\nAssuming that the values within the lockers have been arranged from smallest to largest, the pseudocode for binary search would appear as follows:\n\nIf no doors left\n    Return false\nIf 50 is behind middle door\n    Return true\nElse if 50 < middle door\n    Search left half\nElse if 50 > middle door\n    Search right half\nUsing the nomenclature of code, we can further modify our algorithm as follows:\n\nIf no doors left\n    Return false\nIf 50 is behind doors[middle]\n    Return true\nElse if 50 < doors[middle]\n    Search doors[0] through doors[middle - 1]\nElse if 50 > doors[middle]\n    Search doors[middle + 1] through doors[n - 1]\nNotice, looking at this approximation of code, you can nearly imagine what this might look like in actual code.\n\nRunning Time\nrunning time involves an analysis using big O notation. Take a look at the following graph:\n\nchart with: \"size of problem\" as x-axis; \"time to solve\" as y-axis; red, steep straight line from origin to top of graph close to yellow, less steep straight line from origin to top of graph both labeled \"O(n)\"; green, curved line that gets less and less steep from origin to right of graph labeled \"O(log n)\n\nRather than being ultra-specific about the mathematical efficiency of an algorithm, computer scientists discuss efficiency in terms of the order of various running times.\nIn the above graph, the first algorithm is \n or in the order of n. The second is in \n as well. The third is in \n.\nIt\u2019s the shape of the curve that shows the efficiency of an algorithm. Some common running times we may see are:\n\nOf the running times above, \n is considered the worst running time, \n is the fastest.\nLinear search was of order \n because it could take n steps in the worst case to run.\nBinary search was of order \n because it would take fewer and fewer steps to run even in the worst case.\nProgrammers are interested in both the worst case, or upper bound, and the best case, or lower bound.\nThe \n symbol is used to denote the best case of an algorithm, such as \n.\nThe \n symbol is used to denote where the upper bound and lower bound are the same, where the best case and the worst case running times are the same.\nAs you continue to develop your knowledge in computer science, you will explore these topics in more detail in future courses.\nsearch.c\nYou can implement linear search ourselves by typing code search.c in your terminal window and by writing code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // An array of integers\n    int numbers[] = {20, 500, 10, 5, 100, 1, 50};\n\n    // Search for number\n    int n = get_int(\"Number: \");\n    for (int i = 0; i < 7; i++)\n    {\n        if (numbers[i] == n)\n        {\n            printf(\"Found\\n\");\n            return 0;\n        }\n    }\n    printf(\"Not found\\n\");\n    return 1;\n}\nNotice that the line beginning with int numbers[] allows us to define the values of each element of the array as we create it. Then, in the for loop, we have an implementation of linear search. return 0 is used to indicate success and exit the program. return 1 is used to exist the program with an error (failure).\n\nWe have now implemented linear search ourselves in C!\nWhat if we wanted to search for a string within an array? Modify your code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    // An array of strings\n    string strings[] = {\"battleship\", \"boot\", \"cannon\", \"iron\", \"thimble\", \"top hat\"};\n\n    // Search for string\n    string s = get_string(\"String: \");\n    for (int i = 0; i < 6; i++)\n    {\n        if (strcmp(strings[i], s) == 0)\n        {\n            printf(\"Found\\n\");\n            return 0;\n        }\n    }\n    printf(\"Not found\\n\");\n    return 1;\n}\nNotice that we cannot utilize == as in our previous iteration of this program. Instead, we use strcmp, which comes from the string.h library. strcmp will return 0 if the strings are the same.\n\nIndeed, running this code allows us to iterate over this array of strings to see if a certain string was within it. However, if you see a segmentation fault, where a part of memory was touched by your program that it should not have access to, do make sure you have i < 6 noted above instead of i < 7.\n\nWe can combine these ideas of both numbers and strings into a single program. Type code phonebook.c into your terminal window and write code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    // Arrays of strings\n    string names[] = {\"Carter\", \"David\", \"John\"};\n    string numbers[] = {\"+1-617-495-1000\", \"+1-617-495-1000\", \"+1-949-468-2750\"};\n\n    // Search for name\n    string name = get_string(\"Name: \");\n    for (int i = 0; i < 3; i++)\n    {\n        if (strcmp(names[i], name) == 0)\n        {\n            printf(\"Found %s\\n\", numbers[i]);\n            return 0;\n        }\n    }\n    printf(\"Not found\\n\");\n    return 1;\n}\nNotice that Carter\u2019s number begins with +1-617, David\u2019s phone number starts with +1-617, and John\u2019s number starts with +1-949. Therefore, names[0] is Carter and numbers[0] is Carter\u2019s number. This code will allow us to search the phonebook to for a person\u2019s specific number.\n\nWhile this code works, there are numerous inefficiencies. Indeed, there is a chance that people\u2019s names and numbers may not correspond. Wouldn\u2019t be nice if we could create our own data type where we could associate a person with the phone number?\nData Structures\nIt turns out that C allows a way by which we can create our own data types via a struct.\nWould it not be useful to create our own data type called a person, that has inside of it a name and number.\nModify your code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct\n{\n    string name;\n    string number;\n}\nperson;\n\nint main(void)\n{\n    person people[3];\n\n    people[0].name = \"Carter\";\n    people[0].number = \"+1-617-495-1000\";\n\n    people[1].name = \"David\";\n    people[1].number = \"+1-617-495-1000\";\n\n    people[2].name = \"John\";\n    people[2].number = \"+1-949-468-2750\";\n\n    // Search for name\n    string name = get_string(\"Name: \");\n    for (int i = 0; i < 3; i++)\n    {\n        if (strcmp(people[i].name, name) == 0)\n        {\n            printf(\"Found %s\\n\", people[i].number);\n            return 0;\n        }\n    }\n    printf(\"Not found\\n\");\n    return 1;\n}\nNotice that the code begins with typedef struct where a new datatype called person is defined. Inside a person is a string called name and a string called number. In the main function, begin by creating an array called people that is of type person that is a size of 3. Then, we update the names and phone numbers of the two people in our people array. Most important, notice how the dot notation such as people[0].name allows us to access the person at the 0th location and assign that individual a name.\n\nSorting\nSorting is the act of taking an unsorted list of values and transforming this list into a sorted one.\nWhen a list is sorted, searching that list is far less taxing on the computer. Recall that we can use binary search on a sorted list, but not on an unsorted one.\nIt turns out that there are many different types of sorting algorithms.\nSelection sort is one such search algorithm.\nWe can represent an array as follows:\n\nSeven red lockers side by side with the last labeled as n-1\n\nThe algorithm for selection sort in pseudocode is:\n\nFor i from 0 to n\u20131\n    Find smallest number between numbers[i] and numbers[n-1]\n    Swap smallest number with numbers[i]\nSummarizing those steps, the first time iterating through the list took n - 1 steps. The second time, it took n - 2 steps. Carrying this logic forward, the steps required could be represented as follows:\n\n(n - 1) + (n - 2) + (n - 3) + ... + 1\nThis could be simplified to n(n-1)/2 or, more simply, \n.\nBubble Sort\nBubble sort is another sorting algorithm that works by repeatedly swapping elements to \u201cbubble\u201d larger elements to the end.\nThe pseudocode for bubble sort is:\n\nRepeat n-1 times\n    For i from 0 to n\u20132\n        If numbers[i] and numbers[i+1] out of order\n            Swap them\n    If no swaps\n        Quit\nAs we further sort the array, we know more and more of it becomes sorted, so we only need to look at the pairs of numbers that haven\u2019t been sorted yet.\nAnalyzing selection sort, we made only seven comparisons. Representing this mathematically, where n represents the number of cases, it could be said that selection sort can be analyzed as:\n\n  (n - 1) + (n - 2) + (n - 3) + ... + 1\nor, more simply \n.\n\nConsidering that mathematical analysis, n2 is really the most influential factor in determining the efficiency of this algorithm. Therefore, selection sort is considered to be of the order of \n in the worst case where all values are unsorted. Even when all values are sorted, it will take the same number of steps. Therefore, the best case can be noted as \n. Since both the upper bound and lower bound cases are the same, the efficiency of this algorithm as a whole can be regarded as \n.\nAnalyzing bubble sort, the worst case is \n. The best case is \n.\nYou can visualize a comparison of these algorithms.\nRecursion\nHow could we improve our efficiency in our sorting?\nRecursion is a concept within programming where a function calls itself. We saw this earlier when we saw\u2026\n\nIf no doors left\n    Return false\nIf number behind middle door\n    Return true\nElse if number < middle door\n    Search left half\nElse if number > middle door\n    Search right half\nNotice that we are calling search on smaller and smaller iterations of this problem.\n\nSimilarly, in our pseudocode for Week 0, you can see where recursion was implemented:\n\n1  Pick up phone book\n2  Open to middle of phone book\n3  Look at page\n4  If person is on page\n5      Call person\n6  Else if person is earlier in book\n7      Open to middle of left half of book\n8      Go back to line 3\n9  Else if person is later in book\n10     Open to middle of right half of book\n11     Go back to line 3\n12 Else\n13     Quit\nThis code could have been simplified, to highlight its recursive properties as follows:\n\n1  Pick up phone book\n2  Open to middle of phone book\n3  Look at page\n4  If person is on page\n5      Call person\n6  Else if person is earlier in book\n7      Search left half of book\n9  Else if person is later in book\n10     Search right half of book\n12 Else\n13     Quit\nConsider how in Week 1 we wanted to create a pyramid structure as follows:\n\n  #\n  ##\n  ###\n  ####\nTo implement this using recursion, type code recursion.c into your terminal window and write code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nvoid draw(int n);\n\nint main(void)\n{\n    draw(1);\n}\n\nvoid draw(int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"#\");\n    }\n    printf(\"\\n\");\n\n    draw(n + 1);\n}\nNotice that the draw function calls itself. Further, note that your code may get caught in an infinite loop. To break from this loop, if you get stuck, hit ctrl-c on your keyboard. The reason this creates an infinite loop is that there is nothing telling the program to end. There is no case where the program is done.\n\nWe can correct our code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nvoid draw(int n);\n\nint main(void)\n{\n    // Get height of pyramid\n    int height = get_int(\"Height: \");\n\n    // Draw pyramid\n    draw(height);\n}\n\nvoid draw(int n)\n{\n    // If nothing to draw\n    if (n <= 0)\n    {\n        return;\n    }\n\n    // Draw pyramid of height n - 1\n    draw(n - 1);\n\n    // Draw one more row of width n\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"#\");\n    }\n    printf(\"\\n\");\n}\nNotice the base case will ensure the code does not run forever. The line if (n <= 0) terminates the recursion because the problem has been solved. Every time draw calls itself, it calls itself by n-1. At some point, n-1 will equal 0, resulting in the draw function returning and the program will end.\n\nMerge Sort\nWe can now leverage recursion in our quest for a more efficient sort algorithm and implement what is called merge sort, a very efficient sort algorithm.\nThe pseudocode for merge sort is quite short:\n\nIf only one number\n    Quit\nElse\n    Sort left half of number\n    Sort right half of number\n    Merge sorted halves\nConsider the following list of numbers:\n\n  6341\nFirst, merge sort asks, \u201cis this one number?\u201d The answer is \u201cno,\u201d so the algorithm continues.\n\n  6341\nSecond, merge sort will now split the numbers down the middle (or as close as it can get) and sort the left half of numbers.\n\n  63|41\nThird, merge sort would look at these numbers on the left and ask, \u201cis this one number?\u201d Since the answer is no, it would then split the numbers on the left down the middle.\n\n  6|3\nFourth, merge sort will again ask , \u201cis this one number?\u201d The answer is yes this time! Therefore, it will quit this task and return to the last task it was running at this point:\n\n  63|41\nFifth, merge sort will sort the numbers on the left.\n\n  36|41\nNow, we return to where we left off in the pseudocode now that the left side has been sorted. A similar process of steps 3-5 will occur with the right-hand numbers. This will result in:\n\n  36|14\nBoth halves are now sorted. Finally, the algorithm will merge both sides. It will look at the first number on the left and the first number on the right. It will put the smaller number first, then the second smallest. The algorithm will repeat this for all numbers, resulting in:\n\n  1346\nMerge sort is complete, and the program quits.\nMerge sort is a very efficient sort algorithm with a worst case of \n. The best case is still \n because the algorithm still must visit each place in the list. Therefore, merge sort is also \n since the best case and worst case are the same.\nA final visualization was shared.\nSumming Up\nIn this lesson, you learned about algorithmic thinking and building your own data types. Specifically, you learned\u2026\n\nAlgorithms.\nBig O notation.\nBinary search and linear search.\nVarious sort algorithms, including bubble sort, selection sort, and merge sort.\nRecursion.\nSee you next time!"
        },
        {
            "lecture": 2,
            "content": "Lecture 2\nWelcome!\nCompiling\nDebugging\nArrays\nStrings\nString Length\nCommand-Line Arguments\nExit Status\nCryptography\nSumming Up\nWelcome!\nIn our previous session, we learned about C, a text-based programming language.\nThis week, we are going to take a deeper look at additional building-blocks that will support our goals of learning more about programming from the bottom up.\nFundamentally, in addition to the essentials of programming, this course is about problem-solving. Accordingly, we will also focus further on how to approach computer science problems.\nCompiling\nEncryption is the act of hiding plain text from prying eyes. decrypting, then, is the act of taking an encrypted piece of text and returning it to a human-readable form.\nAn encrypted piece of text may look like the following:\n\nencryption\n\nRecall that last week you learned about a compiler, a specialized computer program that converts source code into machine code that can be understood by a computer.\nFor example, you might have a computer program that looks like this:\n\n#include <stdio.h>\n\nint main(void)\n{\n    printf(\"hello, world\\n\");\n}\nA compiler will take the above code and turn it into the following machine code:\n\nmachine code\n\nVS Code, the programming environment provided to you as a CS50 student, utilizes a compiler called clang or c language.\nIf you were to type make hello, it runs a command that executes clang to create an output file that you can run as a user.\nVS Code has been pre-programmed such that make will run numerous command line arguments along with clang for your convenience as a user.\nConsider the following code:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    string name = get_string(\"What's your name? \");\n    printf(\"hello, %s\\n\", name);\n}\nYou can attempt to enter into the terminal window: clang -o hello hello.c. You will be met by an error that indicates that clang does not know where to find the cs50.h library.\nAttempting again to compile this code, run the following command in the terminal window: clang -o hello hello.c -lcs50. This will enable the compiler to access the cs50.h library.\nRunning in the terminal window ./hello, your program will run as intended.\nWhile the above is offered as an illustration, such that you can understand more deeply the process and concept of compiling code, using make in CS50 is perfectly fine and the expectation!\nCompiling involves major steps, including the following:\nFirst, preprocessing is where the header files in your code, designated by a # (such as #include <cs50.h>) are effectively copied and pasted into your file. During this step, the code from cs50.h is copied into your program. Similarly, just as your code contains #include <stdio.h>, code contained within stdio.h somewhere on your computer is copied to your program. This step can be visualized as follows:\n\nstring get_string(string prompt);\nint printf(string format, ...);\n\nint main(void)\n{\n    string name = get_string(\"What's your name? \");\n    printf(\"hello, %s\\n\", name);\n}\nSecond, compiling is where your program is converted into assembly code. This step can be visualized as follows:\n\ncompiling\n\nThird, assembling involves the compiler converting your assembly code into machine code. This step can be visualized as follows:\n\nassembling\n\nFinally, during the linking step, code from your included libraries are converted also into machine code and combined with your code. The final executable file is then outputted.\n\nlinking\n\nDebugging\nEveryone will make mistakes while coding.\nConsider the following image from last week:\n\nmario\n\nFurther, consider the following code that has a bug purposely inserted within it:\n\n#include <stdio.h>\n\nint main(void)\n{\n    for (int i = 0; i <= 3; i++)\n    {\n        printf(\"#\\n\");\n    }\n}\nType code buggy0.c into the terminal window and write the above code.\nRunning this code, four bricks appear instead of the intended three.\nprintf is a very useful way of debugging your code. You could modify your code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    for (int i = 0; i <= 3; i++)\n    {\n        printf(\"i is %i\\n\", i);\n        printf(\"#\\n\");\n    }\n}\nRunning this code, you will see numerous statements, including i is 0, i is 1, i is 2, and i is 3. Seeing this, you might realize that Further code needs to be corrected as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    for (int i = 0; i < 3; i++)\n    {\n        printf(\"#\\n\");\n    }\n}\nNotice the <= has been replaced with <.\n\nThis code can be further improved as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nvoid print_column(int height);\n\nint main(void)\n{\n    int h = get_int(\"Height: \");\n    print_column(h);\n}\n\nvoid print_column(int height)\n{\n    for (int i = 0; i <= height; i++)\n    {\n        printf(\"#\\n\");\n    }\n}\nNotice that compiling and running this code still results in a bug.\n\nTo address this bug, we will use a new tool at our disposal.\nA second tool in debugging is called a debugger, a software tool created by programmers to help track down bugs in code.\nIn VS Code, a preconfigured debugger has been provided to you.\nTo utilize this debugger, first set a breakpoint by clicking to the left of a line of your code, just to the left of the line number. When you click there, you will see a red dot appearing. Imagine this as a stop sign, asking the compiler to pause such that you can consider what\u2019s happening in this part of your code.\n\nbreak point\n\nSecond, run debug50 ./buggy0. You will notice that after the debugger comes to life that a line of your code will illuminate in a gold-like color. Quite literally, the code has paused at this line of code. Notice in the top left corner how all local variables are being displayed, including h, which has a current does not have a value. At the top of your window, you can click the step over button and it will keep moving through your code. Notice how the value of h increases.\nWhile this tool will not show you where your bug is, it will help you slow down and see how your code is running step by step. You can use step into as a way to look further into the details of your buggy code.\nA final form of debugging is called rubber duck debugging. When you are having challenges with your code, consider how speaking out loud to, quite literally, a rubber duck about the code problem. If you\u2019d rather not talk to a small plastic duck, you are welcome to speak to a human near you! They need not understand how to program: Speaking with them is an opportunity for you to speak about your code.\nArrays\nIn Week 0, we talked about data types such as bool, int, char, string, etc.\nEach data type requires a certain amount of system resources:\nbool 1 byte\nint 4 bytes\nlong 8 bytes\nfloat 4 bytes\ndouble 8 bytes\nchar 1 byte\nstring ? bytes\nInside of your computer, you have a finite amount of memory available.\n\nmemory\n\nPhysically, on the memory of your computer, you can imagine how specific types of data are stored on your computer. You might imagine that a char, which only requires 1 byte of memory, may look as follows:\n\n1 byte\n\nSimilarly, an int, which requires 4 bytes might look as follows:\n\n4 bytes\n\nWe can create a program that explores these concepts. Inside your terminal, type code scores.c and write code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    // Scores\n    int score1 = 72;\n    int score2 = 73;\n    int score3 = 33;\n\n    // Print average\n    printf(\"Average: %f\\n\", (score1 + score2 + score3) / 3.0);\n}\nNotice that the number on the right is a floating point value of 3.0, such that the calculation is rendered as a floating point value in the end.\n\nRunning make scores, the program runs.\nYou can imagine how these variables are stored in memory:\n\nscores in memory\n\nArrays are a way of storing data back-to-back in memory such that this data is easily accessible.\nint scores[3] is a way of telling the compiler to provide you three back-to-back places in memory of size int to store three scores. Considering our program, you can revise your code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // Get scores\n    int scores[3];\n    scores[0] = get_int(\"Score: \");\n    scores[1] = get_int(\"Score: \");\n    scores[2] = get_int(\"Score: \");\n\n    // Print average\n    printf(\"Average: %f\\n\", (scores[0] + scores[1] + scores[2]) / 3.0);\n}\nNotice that score[0] examines the value at this location of memory by indexing into the array called scores at location 0 to see what value is stored there.\n\nYou can see how while the above code works, there is still an opportunity for improving our code. Revise your code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // Get scores\n    int scores[3];\n    for (int i = 0; i < 3; i++)\n    {\n        scores[i] = get_int(\"Score: \");\n    }\n\n    // Print average\n    printf(\"Average: %f\\n\", (scores[0] + scores[1] + scores[2]) / 3.0);\n}\nNotice how we index into scores by using scores[i] where i is supplied by the for loop.\n\nWe can simplify or abstract away the calculation of the average. Modify your code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\n// Constant\nconst int N = 3;\n\n// Prototype\nfloat average(int length, int array[]);\n\nint main(void)\n{\n    // Get scores\n    int scores[N];\n    for (int i = 0; i < N; i++)\n    {\n        scores[i] = get_int(\"Score: \");\n    }\n\n    // Print average\n    printf(\"Average: %f\\n\", average(N, scores));\n}\n\nfloat average(int length, int array[])\n{\n    // Calculate average\n    int sum = 0;\n    for (int i = 0; i < length; i++)\n    {\n        sum += array[i];\n    }\n    return sum / (float) length;\n}\nNotice that a new function called average is declared. Further, notice that a const or constant value of N is declared. Most importantly, notice how the average function takes int array[], which means that the compiler passes an array to this function.\n\nNot only can arrays be containers: They can be passed between functions.\nStrings\nA string is simply an array of variables of type char: an array of characters.\nConsidering the following image, you can see how a string is an array of characters that begins with the first character and ends with a special character called a NUL character:\n\nhi with terminator\n\nImagining this in decimal, your array would look like the following:\n\nhi with decimal\n\nImplementing this in your own code, type code hi.c in the terminal window and write code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    char c1 = 'H';\n    char c2 = 'I';\n    char c3 = '!';\n\n    printf(\"%c%c%c\\n\", c1, c2, c3);\n}\nNotice that this will output a string of characters.\n\nSimilarly, make the following modification to your code:\n\n#include <stdio.h>\n\nint main(void)\n{\n    char c1 = 'H';\n    char c2 = 'I';\n    char c3 = '!';\n\n    printf(\"%i %i %i\\n\", c1, c2, c3);\n}\nNotice that that ASCII codes are printed by replacing %c with %i.\n\nTo further understand how a string works, revise your code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    string s = \"HI!\";\n    printf(\"%c%c%c\\n\", s[0], s[1], s[2]);\n}\nNotice how the printf statement presents three values from our array called s.\n\nAs before, we can replace %c with %i as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    string s = \"HI!\";\n    printf(\"%i %i %i %i\\n\", s[0], s[1], s[2], s[3]);\n}\nNotice that this prints the string\u2019s ASCII codes, including NUL.\n\nLet\u2019s imagine we want to say both HI! and BYE!. Modify your code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    string s = \"HI!\";\n    string t = \"BYE!\";\n\n    printf(\"%s\\n\", s);\n    printf(\"%s\\n\", t);\n}\nNotice that two strings are declared and used in this example.\n\nYou can visualize this as follow:\n\nhi and bye\n\nWe can further improve this code. Modify your code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    string words[2];\n\n    words[0] = \"HI!\";\n    words[1] = \"BYE!\";\n\n    printf(\"%s\\n\", words[0]);\n    printf(\"%s\\n\", words[1]);\n}\nNotice that both strings are stored within a single array of type string.\n\nString Length\nA common problem within programming, and perhaps C more specifically, is to discover the length of an array. How could we implement this in code? Type code length.c in the terminal window and code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // Prompt for user's name\n    string name = get_string(\"Name: \");\n\n    // Count number of characters up until '\\0' (aka NUL)\n    int n = 0;\n    while (name[n] != '\\0')\n    {\n        n++;\n    }\n    printf(\"%i\\n\", n);\n}\nNotice that this code loops until the NUL character is found.\n\nThis code can ben improved by abstracting away the counting as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint string_length(string s);\n\nint main(void)\n{\n    // Prompt for user's name\n    string name = get_string(\"Name: \");\n    int length = string_length(name);\n    printf(\"%i\\n\", length);\n}\n\nint string_length(string s)\n{\n    // Count number of characters up until '\\0' (aka NUL)\n    int n = 0;\n    while (s[n] != '\\0')\n    {\n        n++;\n    }\n    return n;\n}\nSince this is such a common problem within programming, other programmers have created code in the string.h library to find the length of a string. You can find the length of a string by modifying your code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    // Prompt for user's name\n    string name = get_string(\"Name: \");\n    int length = strlen(name);\n    printf(\"%i\\n\", length);\n}\nNotice that this code uses the string.h library, declared at the top of the file. Further, it uses a function from that library called strlen, which calculates the length of the string passed to it.\n\nctype.h is another library that is quite useful. Imagine we wanted to create a program that converted all lowercase characters to uppercase ones. In the terminal window type code uppercase.c and write code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    string s = get_string(\"Before: \");\n    printf(\"After:  \");\n    for (int i = 0, n = strlen(s); i < n; i++)\n    {\n        if (s[i] >= 'a' && s[i] <= 'z')\n        {\n            printf(\"%c\", s[i] - 32);\n        }\n        else\n        {\n            printf(\"%c\", s[i]);\n        }\n    }\n    printf(\"\\n\");\n}\nNotice that this code iterates through each value in the string. The program looks at each character. If the character is lowercase, it subtracts the value 32 from it to convert it to uppercase.\n\nRecalling our previous work from last week, you might remember this ASCII values chart:\n\nascii\n\nWhen a lowercase character has 32 subtracted from it, it results in an uppercase version of that same character.\nWhile the program does what we want, there is an easier way using the ctype.h library. Modify your program as follows:\n\n#include <cs50.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    string s = get_string(\"Before: \");\n    printf(\"After:  \");\n    for (int i = 0, n = strlen(s); i < n; i++)\n    {\n        if (islower(s[i]))\n        {\n            printf(\"%c\", toupper(s[i]));\n        }\n        else\n        {\n            printf(\"%c\", s[i]);\n        }\n    }\n    printf(\"\\n\");\n}\nNotice that the program iterates through each character of the string. The toupper function is passed s[i]. Each character (if lowercase) is converted to uppercase.\n\nIt\u2019s worth mentioning that toupper automatically knows to uppercase only lowercase characters. Hence, your code can be simplified as follows:\n\n#include <cs50.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    string s = get_string(\"Before: \");\n    printf(\"After:  \");\n    for (int i = 0, n = strlen(s); i < n; i++)\n    {\n        printf(\"%c\", toupper(s[i]));\n    }\n    printf(\"\\n\");\n}\nNotice that this code uppercases a string using the ctype library.\n\nYou can read about all the capabilities of the ctype library on the Manual Pages.\nCommand-Line Arguments\nCommand-line arguments are those arguments that are passed to your program at the command line. For example, all those statements you typed after clang are considered command line arguments. You can use these arguments in your own programs!\nIn your terminal window, type code greet.c and write code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    string answer = get_string(\"What's your name? \");\n    printf(\"hello, %s\\n\", answer);\n}\nNotice that this says hello to the user.\n\nStill, would it not be nice to be able to take arguments before the program even runs? Modify your code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(int argc, string argv[])\n{\n    if (argc == 2)\n    {\n        printf(\"hello, %s\\n\", argv[1]);\n    }\n    else\n    {\n        printf(\"hello, world\\n\");\n    }\n}\nNotice that this program knows both argc, the number of command line arguments, and argv which is an array of the characters passed as arguments at the command line.\n\nTherefore, using the syntax of this program, executing ./greet David would result in the program saying hello, David.\nExit Status\nWhen a program ends, a special exit code is provided to the computer.\nWhen a program exits without error, a status code of 0 is provided the computer. Often, when an error occurs that results in the program ending, a status of 1 is provided by the computer.\nYou could write a program as follows that illustrates this by typing code status.c and writing code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(int argc, string argv[])\n{\n    if (argc != 2)\n    {\n        printf(\"Missing command-line argument\\n\");\n        return 1;\n    }\n    printf(\"hello, %s\\n\", argv[1]);\n    return 0;\n}\nNotice that if you fail to provide ./status David, you will get an exit status of 1. However, if you do provide ./status David, you will get an exit status of 0.\n\nYou can imagine how you might use portions of the above program to check if a user provided the correct number of command-line arguments.\nCryptography\nCryptography is the art of ciphering and deciphering a message.\nplaintext and a key are provided to a cipher, resulting in ciphered text.\n\ncryptography\n\nThe key is a special argument passed to the cipher along with the plaintext. The cipher uses the key to make decisions about how to implement its cipher algorithm.\nSumming Up\nIn this lesson, you learned more details about compiling and how data is stored within a computer. Specifically, you learned\u2026\n\nGenerally, how a compiler works.\nHow to debug your code using four methods.\nHow to utilize arrays within your code.\nHow arrays store data in back to back portions of memory.\nHow strings are simply arrays of characters.\nHow to interact with arrays in your code.\nHow command-line arguments can be passed to your programs.\nThe basic building-blocks of cryptography.\nSee you next time!"
        },
        {
            "lecture": 0,
            "content": "Lecture 0\nWelcome!\nWhat\u2019s Ahead\nCommunity!\nComputer Science\nASCII\nUnicode\nRepresentation\nAlgorithms\nPseudocode\nArtificial Intelligence\nScratch\nHello World\nHello, You\nMeow and Abstraction\nConditionals\nOscartime\nIvy\u2019s Hardest Game\nSumming Up\nWelcome!\nThis class is about more than computer programming!\nIndeed, this class is about problem-solving in a way that is exceedingly empowering! You will likely take the problem solving that you learn here will likely be instantly applicable to your work beyond this course and even your career as a whole!\nHowever, it will not be easy! You will be \u201cdrinking from the firehose\u201d of knowledge during this course. You\u2019ll be amazed at what you will be able to accomplish in the coming weeks.\nThis course is far more about you advancing \u201cyou\u201d from \u201cwhere you are today\u201d than hitting some imagined standard.\nThe most important opening consideration in this course: Give the time you need to learn through this course. Everyone learns differently. If something does not work out well at the start, know that with time you will grow and grow in your skill.\nDon\u2019t be scared if this is your first computer science class! For most of your peers, this is their first computer science class too!\nWhat\u2019s Ahead\nYou will be learning this week about Scratch, a visual programming language.\nThen, in future weeks, you will learn about C. That will look something like this:\n\n#include <stdio.h>\n\nint main(void)\n{\n  printf(\"hello, world\\n\");\n}\nFurther, as the weeks progress, you will learn about algorithms.\nYou will learn about memory.\nYou will learn about buggy code and what causes computer crashes.\nYou will learn about data structures such as a hash table.\nThen, we will transition to a new, higher-level language called Python. Your code will look something like this:\n\nprint(\"hello, world\")\nThis class will give you a strong understanding of how recent programming languages developed from the earlier ones.\nYou will learn SQL, JavaScript, HTML, and CSS.\nWe will also be looking at how we can use databases and third-party frameworks to build web applications.\nCommunity!\nYou are part of a community of those taking this course at Harvard College, Harvard Extension School, and via edX.org.\nPuzzle Day and the CS50 Fair\nYou can attend CS50 Lunches and CS50 Hackathon, if you are student on Harvard\u2019s campus.\nComputer Science\nEssentially, computer programming is about taking some input and creating some output - thus solving a problem. What happens in between the input and output, what we could call a black box, is the focus of this course.\n\nBlack box with input and output\n\nFor example, we may need to take attendance for a class. We could use a system called unary to count, one finger at a time.\nComputers today count using a system called binary. It\u2019s from the term binary digit that we get a familiar term called bit. A bit is a zero or one: on or off.\nComputers only speak in terms of zeros and ones. Zeros represent off. Ones represent on. Computers are millions, and perhaps billions, of transistors that are being turned on and off.\nIf you imagine using a light bulb, a single bulb can only count from zero to one.\nHowever, if you were to have three light bulbs, there are more options open to you!\nUsing three light bulbs, the following could represent zero:\n\n0 0 0\nSimilarly, the following would represent one:\n\n0 0 1\nBy this logic, we could propose that the following equals two:\n\n0 1 0\nExtending this logic further, the following represents three:\n\n0 1 1\nFour would appear as:\n\n1 0 0\nWe could, in fact, using only three light bulbs count as high as seven!\n\n1 1 1\nAs a heuristic, we could imagine that the following values represent each possible place in our binary digit:\n\n4 2 1\nComputers use \u2018base-2\u2019 to count. This can be pictured as follows:\n\n2^2  2^1  2^0\n4    2    1\nTherefore, you could say that it would require three bits (the four\u2019s place, the two\u2019s place, and the one\u2019s place) to represent a number as high as seven.\nComputers generally use eight bits (also known as a byte) to represent a number. For example, 00000101 is the number 5 in binary. 11111111 represents the number 255.\nASCII\nJust as numbers are binary patterns of ones and zeros, letters are represented using ones and zeros too!\nSince there is an overlap between the ones and zeros that represent numbers and letters, the ASCII standard was created to map specific letters to specific numbers.\nFor example, the letter A was decided to map to the number 65. 01000001 represents the number 65 in binary.\nIf you received a text message, the binary under that message might represent the numbers 72, 73, and 33. Mapping these out to ASCII, your message would look as follows:\n\nH   I   !\n72  73  33\nThank goodness for standards like ASCII that allow us to agree upon these values!\nHere is an expanded map of ASCII values:\n\nASCII map\n\nIf you wish, you can learn more about ASCII.\nSince binary can only count up to 255 we are limited to the number of characters represented by ASCII.\nUnicode\nAs time has rolled on, there are more and more ways to communicate via text.\nSince there were not enough digits in binary to represent all the various characters that could be represented by humans, the Unicode standard expanded the number of bits that can be transmitted and understood by computers. Unicode includes not only special characters, but emoji as well.\nThere are emoji that you probably use every day. The following may look familiar to you:\n\nemoji\n\nComputer scientists faced a challenge when wanting to assign various skin tones to each emoji to allow the communication to be further personalized. In this case, the creators and contributors of emoji decided that the initial bits would be the structure of the emoji itself, followed by skin tone.\nFor example, the unicode for a generic thumbs up is U+1F44D. However, the following represents the same thumbs up with a different skin tone: U+1F44D U+1F3FD.\nMore and more features are being added to the Unicode standard to represent further characters and emoji.\nIf you wish, you can learn more about Unicode.\nIf you wish, you can learn more about emoji.\nRepresentation\nZeros and ones can be used to represent color.\nRed, green, and blue (called RGB) is a combination of three numbers.\n\nred green blue boxes\n\nTaking our previously used 72, 73, and 33, which said HI! via text, would be interpreted by image readers as a light shade of yellow. The red value would be 72, the green value would be 73, and the blue would be 33.\n\nyellow box\n\nFurther, zeros and ones can be used to represent images, videos, and music!\nImages are simply collections of RGB values.\nVideos are sequences of many images that are stored together, just like a flipbook.\nMusic can be represented through MIDI data.\nAlgorithms\nProblem-solving is central to computer science and computer programming.\nImagine the basic problem of trying to locate a single name in a phone book.\nHow might you go about this?\nOne approach could be to simply read from page one to the next to the next until reaching the last page.\nAnother approach could be to search two pages at a time.\nA final and perhaps better approach could be to go to the middle of the phone book and ask, \u201cIs the name I am looking for to the left or to the right?\u201d Then, repeat this process, cutting the problem in half and half and half.\nEach of these approaches could be called algorithms. The speed of each of these algorithms can be pictured as follows in what is called big-O notation:\n\nbig o notation\n\nNotice that the first algorithm, highlighted in red, has a big-O of n because if there are 100 names in the phone book, it could take up to 100 tries to find the correct name. The second algorithm, where two pages were searched at a time, has a big-O of \u2018n/2\u2019 because we searched twice as fast through the pages. The final algorithm has a big-O of log2n as doubling the problem would only result in one more step to solve the problem.\n\nPseudocode\nThe ability to create pseudocode is central to one\u2019s success in both this class and in computer programming.\nPseudocode is a human-readable version of your code. For example, considering the third algorithm above, we could compose pseudocode as follows:\n\n1  Pick up phone book\n2  Open to middle of phone book\n3  Look at page\n4  If person is on page\n5      Call person\n6  Else if person is earlier in book\n7      Open to middle of left half of book\n8      Go back to line 3\n9  Else if person is later in book\n10     Open to middle of right half of book\n11     Go back to line 3\n12 Else\n13     Quit\nPseudocoding is such an important skill for at least two reasons. First, when you pseudocode before you create formal code, it allows you to think through the logic of your problem in advance. Second, when you pseudocode, you can later provide this information to others that are seeking to understand your coding decisions and how your code works.\nNotice that the language within our pseudocode has some unique features. First, some of these lines begin with verbs like pick up, open, look at. Later, we will call these functions.\nSecond, notice that some lines include statements like if or else if. These are called conditionals.\nThird, notice how there are expressions that can be stated as true or false, such as \u201cperson is earlier in the book.\u201d We call these boolean expressions.\nFinally, notice how these statements like \u201cgo back to line 3.\u201d We call these loops.\nThese building blocks are the fundamentals of programming.\nIn the context of Scratch, which is discussed below, we will use each of the above basic building blocks of programming.\nArtificial Intelligence\nConsider how we can utilize the building blocks above to start creating our own artificial intelligence. Look at the following pseudocode:\n\nIf student says hello\n    Say hello back\nElse if student says goodbye\n    Say goodbye back\nElse if student asks how you are\n    Say you're well\nElse if student asks why 111 in binary is 7 in decimal\n...\nNotice how just to program a handful of interactions, many lines of code would be required. How many lines of code would be required for thousands or tens of thousands of possible interactions?\n\nlarge language models look at patterns in large blocks of language. Such language models attempt to create a best guess of what words come after one another or alongside one another.\nAs very useful in many avenues of life and work, we stipulate that the utilization of AI-based software other than CS50\u2019s own is not reasonable.\nCS50\u2019s own AI-based software tool called CS50 Duck is an AI helper that you can use during this course. It will help you, but not give away the entire answers to the course\u2019s problems.\nScratch\nScratch is a visual programming language developed by MIT.\nScratch utilizes the same essential coding building blocks that we covered earlier in this lecture.\nScratch is a great way to get into computer programming because it allows you to play with these building blocks in a visual manner, not having to be concerned about the syntax of curly braces, semicolons, parentheses, and the like.\nScratch IDE (integrated development environment) looks like the following:\n\nscratch interface\n\nNotice that on the left, there are building blocks that you can use in your programming. To the immediate right of the building blocks, there is the area to which you can drag blocks to build a program. To the right of that, you see the stage where a cat stands. The stage is where your programming comes to life.\n\nScratch operates on a coordinate system as follows:\n\nscratch coordinate system\n\nNotice that the center of the stage is at coordinate (0,0). Right now, the cat\u2019s position is at that same position.\n\nHello World\nTo begin, drag the \u201cwhen green flag clicked\u201d building block to the programming area. Then, drag the say building block to the programming area and attach it to the previous block.\n\nwhen\nclicked\nsay\nhello, world\nNotice that when you click the green flag now, on the stage, the cat says, \u201chello world.\u201d\n\nThis illustrates quite well what we were discussing earlier regarding programming:\n\nscratch with black box\n\nNotice that the input hello world is passed to the function say, and the side effect of that function running is the cat saying hello world.\n\nHello, You\nWe can make your program more interactive by having the cat say hello to someone specific. Modify your program as below:\n\nwhen\nclicked\nask\nWhat's your name?\nand\nwait\nsay\njoin\nhello,\nanswer\nNotice that when the green flag is clicked, the function ask is run. The program prompts you, the user, What's your name? It then stores that name in the variable called answer. The program then passes answer to a special function called join, which combines two strings of text hello, and whatever name was provided. These collectively are passed to the say function. The cat says, Hello, and a name. Your program is now interactive.\n\nQuite similarly, we can modify our program as follows:\n\nwhen\nclicked\nask\nWhat's your name?\nand\nwait\nspeak\njoin\nhello,\nanswer\nNotice that this program, when the green flag is clicked, passes the same variable, joined with hello, to a function called speak.\n\nMeow and Abstraction\nAlong with pseudocoding, abstraction is an essential skill and concept within computer programming.\nAbstraction is the act of simplifying a problem into smaller and smaller problems.\nFor example, if you were hosting a huge dinner for your friends, the problem of having to cook the entire meal could be quite overwhelming! However, if you break down the task of cooking the meal into smaller and smaller tasks (or problems), the big task of creating this delicious meal might feel less challenging.\nIn programming, and even within Scratch, we can see abstraction in action. In your programming area, program as follows:\n\nwhen\nclicked\nplay\nsound\nMeow\nuntil\ndone\nwait\n1\nseconds\nplay\nsound\nMeow\nuntil\ndone\nwait\n1\nseconds\nplay\nsound\nMeow\nuntil\ndone\nNotice that you are doing the same thing over and over again. Indeed, if you see yourself repeatedly coding the same statements, it\u2019s likely the case that you could program more artfully \u2013 abstracting away this repetitive code.\n\nYou can modify your code as follows:\n\nwhen\nclicked\nrepeat\n3\nplay\nsound\nMeow\nuntil\ndone\nwait\n1\nseconds\nNotice that the loop does exactly as the previous program did. However, the problem is simplified by abstracting away the repetition to a block that repeats the code for us.\n\nWe can even advance this further by using the define block, where you can create your own block (your own function)! Write code as follows:\n\ndefine\nmeow\nplay\nsound\nMeow\nuntil\ndone\nwait\n1\nseconds\nwhen\nclicked\nrepeat\n3\nmeow\nNotice that we are defining our own block called meow. The function plays the sound meow, then waits one second. Below that, you can see that when the green flag is clicked, our meow function is repeated three times.\n\nWe can even provide a way by which the function can take an input n and repeat a number of times:\n\ndefine\nmeow\nn\ntimes\nrepeat\nn\nplay\nsound\nmeow\nuntil\ndone\nwait\n1\nseconds\nNotice how n is taken from \u201cmeow n times.\u201d n is passed to the meow function through the define block.\n\nThe cat, by the way, we can call a sprite \u2013 a general term used in game programming for an object or character on the screen with which the player will interact.\nConditionals\nconditionals are an essential building block of programming, where the program looks to see if a specific condition has been met. If a condition is met, the program does something.\nTo illustrate a conditional, write code as follows:\n\nwhen\nclicked\nforever\nif\ntouching\nmouse-pointer\n?\nthen\nplay\nsound\nMeow\nuntil\ndone\nNotice that the forever block is utilized such that the if block is triggered over and over again, such that it can check continuously if the cat is touching the mouse pointer.\n\nWe can modify our program as follows to integrate video sensing:\n\nwhen\nvideo\nmotion\n>\n50\nplay\nsound\nMeow\nuntil\ndone\nRemember, programming is often a process of trial and error. If you get frustrated, take time to talk yourself through the problem at hand. What is the specific problem that you are working on right now? What is working? What is not working?\nOscartime\nWe showed you in this lecture a number of Scratch programs to stoke your imagination.\nOscartime is one of David\u2019s own Scratch programs \u2013 though the music may haunt him because of the number of hours he listened to it while creating this program. Take a few moments to play through the game yourself.\nBuilding Oscartime ourselves, we first add the lamp post.\n\noscartime interface\n\nThen, write code as follows:\n\nwhen\nclicked\nswitch\ncostume\nto\noscar1\nforever\nif\ntouching\nmouse-pointer\n?\nthen\nswitch\ncostume\nto\noscar2\nelse\nswitch\ncostume\nto\noscar1\nNotice that moving your mouse over Oscar changes his costume. You can learn more by exploring these code blocks.\n\nThen, modify your code as follow to create a falling piece of trash:\n\nwhen\nclicked\ngo\nto\nx:\npick\nrandom\n-240\nto\n240\ny:\n180\nforever\nif\ndistance\nto\nfloor\n>\n0\nthen\nchange\ny\nby\n-3\nNotice that the trash\u2019s position on the y-axis always begins at 180. The x position is randomized. While the trash is above the floor, it goes down 3 pixels at a time. You can learn more by exploring these code blocks.\n\nNext, modify your code as follows to allow for the possibility of dragging trash.\n\nwhen\nclicked\nforever\nif\nmouse\ndown?\nand\ntouching\nmouse-pointer\n?\nthen\ngo\nto\nmouse-pointer\nYou can learn more by exploring these code blocks.\n\nNext, we can implement the scoring variables as follows:\n\nwhen\nclicked\nforever\nif\ntouching\nOscar\n?\nthen\nchange\nscore\nby\n1\ngo\nto\nx:\npick\nrandom\n-240\nto\n240\ny:\n180\nYou can learn more by exploring these code blocks.\n\nGo try the full game Oscartime.\nIvy\u2019s Hardest Game\nMoving away from Oscartime to Ivy\u2019s Hardest Game, we can now imagine how to implement movement within our program.\nOur program has three main components.\nFirst, write code as follows:\n\nwhen\nclicked\ngo\nto\nx:\n0\ny:\n0\nforever\nlisten\nfor\nkeyboard\nfeel\nfor\nwalls\nNotice that when the green flag is clicked, our sprite moves to the center of the stage at coordinates (0,0) and then listens for the keyboard and checks for walls forever.\n\nSecond, add this second group of code blocks:\n\ndefine\nlisten\nfor\nkeyboard\nif\nkey\nup arrow\npressed?\nthen\nchange\ny\nby\n1\nif\nkey\ndown arrow\npressed?\nthen\nchange\ny\nby\n-1\nif\nkey\nright arrow\npressed?\nthen\nchange\nx\nby\n1\nif\nkey\nleft arrow\npressed?\nthen\nchange\nx\nby\n-1\nNotice how we have created a custom listen for keyboard script. For each of our arrow keys on the keyboard, it will move the sprite around the screen.\n\nFinally, add this group of code blocks:\n\ndefine\nfeel\nfor\nwalls\nif\ntouching\nleft wall\n?\nthen\nchange\nx\nby\n1\nif\ntouching\nright wall\n?\nthen\nchange\nx\nby\n-1\nNotice how we also have a custom feel for walls script. When a sprite touches a wall, it moves it back to a safe position \u2013 preventing it from walking off the screen.\n\nYou can learn more by exploring these code blocks.\nGo try the full game Ivy\u2019s Hardest Game.\nScratch allows for many sprites to be on the screen at once.\nAdding another sprite, add the following code blocks to your program:\n\nwhen\nclicked\ngo\nto\nx:\n0\ny:\n0\npoint\nin\ndirection\n90\nforever\nif\ntouching\nleft wall\n?\nor\ntouching\nright wall\n?\nthen\nturn\n180\ndegrees\nmove\n1\nsteps\nNotice how the Yale sprite seems to get in the way of the Harvard sprite by moving back and forth. When it bumps into a wall, it turns around until it bumps the wall again. You can learn more by exploring these code blocks.\n\nYou can even make a sprite follow another sprite. Adding another sprite, add the following code blocks to your program:\n\nwhen\nclicked\ngo\nto\nrandom position\nforever\npoint\ntowards\nHarvard\nmove\n1\nsteps\nNotice how the MIT logo now seems to follow around the Harvard one. You can learn more by exploring these code blocks.\n\nGo try the full game Ivy\u2019s Hardest Game.\nSumming Up\nIn this lesson, you learned how this course sits in the wide world of computer science and programming. You learned\u2026\n\nFew students come to this class with prior programming experience!\nYou are not alone! You are part of a community.\nProblem solving is the essence of the work of computer scientists.\nThis course is not simply about programming \u2013 this course will introduce you to a new way of learning that you can apply to almost every area of life.\nHow numbers, text, images, music, and video are understood by computers.\nThe fundamental programming skill of pseudocoding.\nReasonable and unreasonable ways to utilize AI in this course.\nHow abstraction will play a role in your future work in this course.\nThe basic building blocks of programming, including functions, conditionals, loops, and variables.\nHow to build a project in Scratch.\nSee you next time!\n"
        },
        {
            "lecture": 1,
            "content": "Lecture 1\nWelcome!\nHello World\nFunctions\nVariables\nConditionals\nLoops\nOperators and Abstraction\nLinux and the Command Line\nMario\nComments\nTypes\nSumming Up\nWelcome!\nIn our previous session, we learned about Scratch, a visual programming language.\nIndeed, all the essential programming concepts presented in Scratch will be utilized as you learn how to program any programming language.\nRecall that machines only understand binary. Where humans write source code, a list of instructions for the computer that is human readable, machines only understand what we can now call machine code. This machine code is a pattern of ones and zeros that produces a desired effect.\nIt turns out that we can convert source code into machine code using a very special piece of software called a compiler. Today, we will be introducing you to a compiler that will allow you to convert source code in the programming language C into machine code.\nToday, in addition to learning about how to code, you will be learning about how to write good code.\nCode can be evaluated upon three axes. First, correctness refers to \u201cdoes the code run as intended?\u201d Second, design refers to \u201chow well is the code designed?\u201d Finally, style refers to \u201chow aesthetically pleasing and consistent is the code?\u201d\nHello World\nThe integrated development environment (IDE) that is utilized for this course is Visual Studio Code, affectionately referred to as , which can be accessed via that same url, or simply as *VS Code.*\nOne of the most important reasons we utilize VS Code is that it has all the software required for the course already pre-loaded on it. This course and the instructions herein were designed with VS Code in mind.\nManually installing the necessary software for the course on your own computer is a cumbersome headache. Best always to utilize VS Code for assignments in this course.\nYou can open VS Code at cs50.dev.\nThe compiler can be divided into a number of regions:\n\nIDE Notice that there is a file explorer on the left side where you can find your files. Further, notice that there is a region in the middle called a text editor where you can edit your program. Finally, there is a command line interface, known as a CLI, command line, or terminal window where we can send commands to the computer in the cloud.\n\nWe will be using three commands to write, compile, and run our first program:\n\ncode hello.c\n\nmake hello\n\n./hello\n\nThe first command, code hello.c creates a file and allows us to type instructions for this program. The second command, make hello, compiles the file from our instructions in C and creates an executable file called hello. The last command, ./hello, runs the program called hello.\n\nWe can build your first program in C by typing code hello.c into the terminal window. Notice that we deliberately lowercased the entire filename and included the .c extension. Then, in the text editor that appears, write code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    printf(\"hello, world\\n\");\n}\nNote that every single character above serves a purpose. If you type it incorrectly, the program will not run. printf is a function that can output a line of text. Notice the placement of the quotes and the semicolon. Further, notice that the \\n creates a new line after the words hello, world.\n\nClicking back in the terminal window, you can compile your code by executing make hello. Notice that we are omitting .c. make is a compiler that will look for our hello.c file and turn it into a program called hello. If executing this command results in no errors, you can proceed. If not, double-check your code to ensure it matches the above.\nNow, type ./hello and your program will execute saying hello, world.\nNow, open the file explorer on the left. You will notice that there is now both a file called hello.c and another file called hello. hello.c is able to be read by the compiler: It\u2019s where your code is stored. hello is an executable file that you can run, but cannot be read by the compiler.\nFunctions\nIn Scratch, we utilized the say block to display any text on the screen. Indeed, in C, we have a function called printf that does exactly this.\nNotice our code already invokes this function:\n\nprintf(\"hello, world\\n\");\nNotice that the printf function is called. The argument passed to printf is \u2018hello, world\\n\u2019. The statement of code is closed with a ;.\n\nA common error in C programming is the omission of a semicolon. Modify your code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    printf(\"hello, world\\n\")\n}\nNotice the semicolon is now gone.\n\nIn your terminal window, run make hello. You will now be met with numerous errors! Placing the semicolon back in the correct position and running make hello again, the errors go away.\nNotice also the special symbol \\n in your code. Try removing those characters and making your program again by executing make hello. Typing ./hello in the terminal window, how did your program change? This \\ character is called an escape character that tells the compiler that \\n is a special instruction.\nRestore your program to the following:\n\n#include <stdio.h>\n\nint main(void)\n{\n    printf(\"hello, world\\n\");\n}\nNotice the semicolon and \\n have been restored.\n\nThe statement at the start of the code #include <stdio.h> is a very special command that tells the compile that you want to use the capabilities of a library called stdio.h, a header file. This allows you, among many other things, to utilize the printf function. You can read about all the capabilities of this library on the Manual Pages. The Manual Pages provide a means by which to better understand what various commands do and how they function.\nLibraries are collections of pre-written functions that others have written in the past that we can utilize in our code.\nIt turns out that CS50 has its own library called cs50.h. Let\u2019s use this library in your program.\nVariables\nRecall that in Scratch, we had the ability to ask the user \u201cWhat\u2019s your name?\u201d and say \u201chello\u201d with that name appended to it.\nIn C, we can do the same. Modify your code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    string answer = get_string(\"What's your name? \");\n    printf(\"hello, %s\\n\", answer);\n}\nThe get_string function is used to get a string from the user. Then, the variable answer is passed to the printf function. %s tells the printf function to prepare itself to receive a string.\n\nanswer is a special holding place we call a variable. answer is of type string and can hold any string within it. There are many data types, such as int, bool, char, and many others.\n%s is a placeholder called a format code that tells the printf function to prepare to receive a string. answer is the string being passed to %s.\nRunning make hello again in the terminal window, notice that numerous errors appear.\nLooking at the errors string and get_string are not recognized by the compiler. We have to teach the compiler these features by adding a library called cs50.h:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    string answer = get_string(\"What's your name? \");\n    printf(\"hello, %s\\n\", answer);\n}\nNotice that #include <cs50.h> has been added to the top of your code.\n\nNow running make hello again in the terminal window, you can run your program by typing ./hello. The program now asks for your name and then says hello with your name attached, as intended.\nprintf allows for many format codes. Here is a noncomprehensive list of ones you may utilize in this course:\n\n%c\n\n%f\n\n%i\n\n%li\n\n%s\n%s is used for string variables. %i is used for int or integer variables. You can find out more about this on the Manual Pages\n\nConditionals\nAnother building block you utilized within Scratch was that of conditionals. For example, you might want to do one thing if x is greater than y. Further, you might want to do something else if that condition is not met.\nWe look at a few examples from Scratch.\nIn C, you can assign a value to an int or integer as follows:\n\nint counter = 0;\nNotice how a variable called counter of type int is assigned the value 0.\n\nC can also be programmed to add one to counter as follows:\n\ncounter = counter + 1;\nNotice how 1 is added to the value of counter.\n\nThis can be represented also as:\n\ncounter = counter++;\nNotice how 1 is added to the value of counter. However the ++ is used instead of counter + 1.\n\nYou can also subtract one from counter as follows:\n\ncounter = counter--;\nNotice how 1 is removed to the value of counter.\n\nUsing this new knowledge about how to assign values to variables, you can program your first conditional statement.\nIn the terminal window, type code compare.c and write code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    int x = get_int(\"What's x? \");\n    int y = get_int(\"What's y? \");\n\n    if (x < y)\n    {\n        printf(\"x is less than y\\n\");\n    }\n}\nNotice that we create two variables, an int or integer called x and another called y. The values of these are populated using the get_int function.\n\nYou can run your code by executing make compare in the terminal window, followed by ./compare. If you get any error messages, check your code for errors.\nFlow charts are a way by which you can examine how a computer program functions. Such charts can be used to examine the efficiency of our code.\nLooking at a flow chart of the above code, we can notice numerous shortcomings.\nWe can improve your program by coding as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    int x = get_int(\"What's x? \");\n    int y = get_int(\"What's y? \");\n\n    if (x < y)\n    {\n        printf(\"x is less than y\\n\");\n    }\n    else if (x > y)\n    {\n        printf(\"x is greater than y\\n\");\n    }\n    else\n    {\n        printf(\"x is equal to y\\n\");\n    }\n}\nNotice that all potential outcomes are now accounted for.\n\nYou can re-make and re-run your program and test it out.\nExamining this program on a flow chart, you can see the efficiency of our code design decisions.\nConsidering another data type called a char we can start a new program by typing code agree.c into the terminal window.\nWhere a string is a series of characters, a char is a single character.\nIn the text editor, write code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // Prompt user to agree\n    char c = get_char(\"Do you agree? \");\n\n    // Check whether agreed\n    if (c == 'Y' || c == 'y')\n    {\n        printf(\"Agreed.\\n\");\n    }\n    else if (c == 'N' || c == 'n')\n    {\n        printf(\"Not agreed.\\n\");\n    }\n}\nNotice that single quotes are utilized for single characters. Further, notice that == ensure that something is equal to something else, where a single equal sign would have a very different function in C. Finally, notice that || effectively means or.\n\nYou can test your code by typing make agree into the terminal window, followed by ./agree.\nLoops\nWe can also utilize the loops building block from Scratch in our C programs.\nWe look at a few examples from Scratch. Consider the following code:\n\nint counter = 3;\nwhile (counter > 0)\n{\n    printf(\"meow\\n\");\n    counter = counter - 1;\n}\nNotice that his code assigns the value of 3 to the counter variable. Then, the while loop says meow and removes one from the counter for each iteration. Once the counter is not greater than zero, the loop ends.\n\nIn your terminal window, type code meow.c and write code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    printf(\"meow\\n\");\n    printf(\"meow\\n\");\n    printf(\"meow\\n\");\n}\nNotice this does as intended but has an opportunity for better design.\n\nWe can improve our program by modifying your code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    int i = 3;\n    while (i > 0)\n    {\n        printf(\"meow\\n\");\n        i--;\n    }\n}\nNotice that we create an int called i and assign it the value 3. Then, we create a while loop that will run as long as i > 0. Then, the loop runs. Every time 1 is subtracted to i using the i-- statement.\n\nSimilarly, we can implement a count-up of sorts by modifying our code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    int i = 1;\n    while (i <= 3)\n    {\n        printf(\"meow\\n\");\n        i++;\n    }\n}\nNotice how our counter i is started at 1. Each time the loop runs, it will increment the counter by 1. Once the counter is greater than 3, it will stop the loop.\n\nGenerally, in computer science we count from zero. Best to revise your code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    int i = 0;\n    while (i < 3)\n    {\n        printf(\"meow\\n\");\n        i++;\n    }\n}\nNotice we now count from zero.\n\nAnother tool in our toolbox for looping is a for loop.\nYou can further improve the design of our meow.c program using a for loop. Modify your code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    for (int i = 0; i < 3; i++)\n    {\n        printf(\"meow\\n\");\n    }\n}\nNotice that the for loop includes three arguments. The first argument int i = 0 starts our counter at zero. The second argument i < 3 is the condition that is being checked. Finally, the argument i++ tells the loop to increment by one each time the loop runs.\n\nWe can even loop forever using the following code:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    while (true)\n    {\n        printf(\"meow\\n\");\n    }\n}\nNotice that true will always be the case. Therefore, the code will always run. You will lose control of your terminal window by running this code. You can break from an infinite by hitting control-C on your keyboard.\n\nWhile we will provide much more guidance later, you can create your own function within C as follows:\n\nvoid meow(void)\n{\n    printf(\"meow\\n\");\n}\nThe initial void means that the function does not return any values. The (void) means that no values are being provided to the function.\n\nThis function can be used in the main function as follows:\n\n#include <stdio.h>\n\nvoid meow(void);\n\nint main(void)\n{\n    for (int i = 0; i < 3; i++)\n    {\n        meow();\n    }\n}\n\nvoid meow(void)\n{\n    printf(\"meow\\n\");\n}\nNotice how the meow function is called with the meow() instruction. This is possible because the meow function is defined at the bottom of the code and the prototype of the function is provided at the top of the code as void meow(void).\n\nYour meow function can be further modified to accept input:\n\n#include <stdio.h>\n\nvoid meow(int n);\n\nint main(void)\n{\n    meow(3);\n}\n\n// Meow some number of times\nvoid meow(int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"meow\\n\");\n    }\n}\nNotice that the prototype has changed to void meow(int n) to show that meow accepts an int as its input.\n\nOperators and Abstraction\nYou can implement a calculator in C. In your terminal, type code calculator.c and write code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // Prompt user for x\n    int x = get_int(\"x: \");\n\n    // Prompt user for y\n    int y = get_int(\"y: \");\n\n    // Perform addition\n    printf(\"%i\\n\", x + y);\n}\nNotice how the get_int function is utilized to obtain an integer from the user twice. One integer is stored in the int variable called x. Another is stored in the int variable called y. Then, the printf function prints the value of x + y, designated by the %i symbol.\n\nOperators refer to the mathematical operations that are supported by your compiler. In C, these mathematical operators include:\n\n+ for addition\n- for subtraction\n* for multiplication\n/ for division\n% for remainder\nAbstraction is the art of simplifying our code such that it deals with smaller and smaller problems.\nExpanding on our previously acquired knowledge about functions, we could abstract away the addition into a function. Modify your code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint add(int a, int b);\n\nint main(void)\n{\n    // Prompt user for x\n    int x = get_int(\"x: \");\n\n    // Prompt user for y\n    int y = get_int(\"y: \");\n\n    // Perform addition\n    int z = add(x, y);\n    printf(\"%i\\n\", z);\n}\n\nint add(int a, int b)\n{\n    int c = a + b;\n    return c;\n}\nNotice that the add function takes two variables as its input. These values are assigned to a and b and preforms a calculation, returning the value of c. Further, notice that the scope (or context in which variables exist) of x is the main function. The variable c is only within the scope of the add function.\n\nThe design of this program can be further improved as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint add(int a, int b);\n\nint main(void)\n{\n    // Prompt user for x\n    int x = get_int(\"x: \");\n\n    // Prompt user for y\n    int y = get_int(\"y: \");\n\n    // Perform addition\n    printf(\"%i\\n\", add(x, y));\n}\n\nint add(int a, int b)\n{\n    return a + b;\n}\nNotice that c in the add function is removed entirely.\n\nWhile very useful to be able to abstract away to an add function, you can also perform addition through truncation as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // Prompt user for x\n    long x = get_long(\"x: \");\n\n    // Prompt user for y\n    long y = get_long(\"y: \");\n\n    // Perform addition\n    printf(\"%li\\n\", x + y);\n}\nNotice that the addition is performed within the printf function.\n\nSimilarly, division can be performed as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // Prompt user for x\n    int x = get_int(\"x: \");\n\n    // Prompt user for y\n    int y = get_int(\"y: \");\n\n    // Divide x by y\n    printf(\"%i\\n\", x / y);\n}\nNotice that division is performed within the printf function.\n\nLinux and the Command Line\nLinux is an operating system that is accessible via the command line in the terminal window in VS Code.\nSome common command-line arguments we may use include:\ncd, for changing our current directory (folder)\ncp, for copying files and directories\nls, for listing files in a directory\nmkdir, for making a directory\nmv, for moving (renaming) files and directories\nrm, for removing (deleting) files\nrmdir, for removing (deleting) directories\nThe most commonly used is ls which will list all the files in the current directory or directory. Go ahead and type ls into the terminal window and hit enter. You\u2019ll see all the files in the current folder.\nAnother useful command is mv, where you can move a file from one file to another. For example, you could use this command to rename Hello.c (notice the uppercase H) to hello.c by typing mv Hello.c hello.c.\nYou can also create folders. You can type mkdir pset1 to create a directory called pset1.\nYou can then use cd pset1 to change your current directory to pset1.\nMario\nEverything we\u2019ve discussed today has focused on various building-blocks of your work as an emerging computer scientist.\nThe following will help you orient toward working on a problem set for this class in general: How does one approach a computer science related problem?\nImagine we wanted to emulate the visual of the game Super Mario Bros. Considering the four question-blocks pictured, how could we create code that roughly represents these four horizontal blocks?\n\nMario Question Marks\n\nIn the terminal window, type code mario.c and code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    for (int i = 0; i < 4; i++)\n    {\n        printf(\"?\");\n    }\n    printf(\"\\n\");\n}\nNotice how four question marks are printed here using a loop.\n\nSimilarly, we can apply this same logic to be able to create three vertical blocks.\n\nMario Blocks\n\nTo accomplish this, modify your code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    for (int i = 0; i < 3; i++)\n    {\n        printf(\"#\\n\");\n    }\n}\nNotice how three vertical bricks are printed using a loop.\n\nWhat if we wanted to combine these ideas to create a three-by-three group of blocks?\n\nMario Grid\n\nWe can follow the logic above, combining the same ideas. Modify your code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            printf(\"#\");\n        }\n        printf(\"\\n\");\n    }\n}\nNotice that one loop is inside another. The first loop defines what vertical row is being printed. For each row, three columns are printed. After each row, a new line is printed.\n\nWhat if we wanted to ensure that the number of blocks to be constant, that is, unchangeable? Modify your code as follows:\n\nint main(void)\n{\n    const int n = 3;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            printf(\"#\");\n        }\n        printf(\"\\n\");\n    }\n}\nNotice how n is now a constant. It can never be changed.\n\nAs illustrated earlier in this lecture, we can make our code prompt the user for the size of the grid. Modify your code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    int n = get_int(\"Size: \");\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            printf(\"#\");\n        }\n        printf(\"\\n\");\n    }\n}\nNotice that get_int is used to prompt the user.\n\nA general piece of advice within programming is that you should never fully trust your user. They will likely misbehave, typing incorrect values where they should not. We can protect our program from bad behavior by checking to make sure the user\u2019s input satisfies our needs. Modify your code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    int n;\n    do\n    {\n        n = get_int(\"Size: \");\n    }\n    while (n < 1);\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            printf(\"#\");\n        }\n        printf(\"\\n\");\n    }\n}\nNotice how the user is continuously prompted for the size until the user\u2019s input is 1 or greater.\n\nComments\nComments are fundamental parts of a computer program, where you leave explanatory remarks to yourself and others that may be collaborating with you regarding your code.\nAll code you create for this course must include robust comments.\nTypically each comment is a few words or more, providing the reader an opportunity to understand what is happening in a specific block of code. Further, such comments serve as a reminder for you later when you need to revise your code.\nComments involve placing // into your code, followed by a comment. Modify your code as follows to integrate comments:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // Prompt user for positive integer\n    int n;\n    do\n    {\n        n = get_int(\"Size: \");\n    }\n    while (n < 1);\n\n    // Print an n-by-n grid of bricks\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            printf(\"#\");\n        }\n        printf(\"\\n\");\n    }\n}\nNotice how each comment begins with a //.\n\nTypes\nOne of C\u2019s shortcomings is the ease by which it managing memory. While C provides you immense control over how memory is utilized, programmers have to be very aware of potential pitfalls of memory management.\nTypes refer to the possible data that can be stored within a variable. For example, a char is designed to accommodate a single character like a or 2.\nTypes are very important because each type has specific limits. For example, because of the limits in memory, the highest value of an int can be 4294967295. If you attempt to count an int higher, integer overflow will result where an incorrect value will be stored in this variable.\nThe number of bits limits how high and low we can count.\nTypes with which you might interact during this course include:\n\nbool, a Boolean expression of either true or false\nchar, a single character like a or 2\ndouble, a floating-point value with more digits than a float\nfloat, a floating-point value, or real number with a decimal value\nint, integers up to a certain size, or number of bits\nlong, integers with more bits, so they can count higher than an int\nstring, a string of characters\nAs you are coding, pay special attention to the types of variables you are using to avoid problems within your code.\nWe examined some examples of disasters that can occur through memory-related errors.\nSumming Up\nIn this lesson, you learned how to apply the building blocks you learned in Scratch to the C programming language. You learned\u2026\n\nHow to create your first program in C.\nPredefined functions that come natively with C and how to implement your own functions.\nHow to use variables, conditionals, and loops.\nHow to approach abstraction to simplify and improve your code.\nHow to approach problem-solving for a computer science problem.\nHow to use the Linux command line.\nHow to integrate comments into your code.\nHow to utilize types and operators.\nSee you next time!"
        },
        {
            "lecture": 5,
            "content": "Lecture 5\nWelcome!\nData Structures\nStacks and Queues\nJack Learns the Facts\nResizing Arrays\nLinked Lists\nTrees\nDictionaries\nHashing and Hash Tables\nTries\nSumming Up\nWelcome!\nAll the prior weeks have presented you with the fundamental building blocks of programming.\nAll you have learned in C will enable you to implement these building blocks in higher-level programming languages such as Python.\nToday, we are going to talk about organizing data in memory and design possibilities that emerge from your growing knowledge.\nData Structures\nData structures essentially are forms of organization in memory.\nThere are many ways to organize data in memory.\nAbstract data structures are those that we can conceptually imagine. When learning about computer science, it\u2019s often useful to begin with these conceptual data structures. Learning these will make it easier later to understand how to implement more concrete data structures.\nStacks and Queues\nQueues are one form of abstract data structure.\nQueues have specific properties. Namely, they are FIFO or \u201cfirst in first out.\u201d You can imagine yourself in a line for a ride at an amusement park. The first person in the line gets to go on the ride first. The last person gets to go on the ride last.\nQueues have specific actions associated with them. For example, an item can be enqueued; that is, the item can join the line or queue. Further, an item can be dequeued or leave the queue once it reaches the front of the line.\nQueues contrast a stack. Fundamentally, the properties of a stack are different than a queue. Specifically, it is LIFO or \u201clast in first out.\u201d Just like stacking trays in a cafeteria, a tray that is placed in a stack last is the first that may be picked up.\nStacks have specific actions associated with them. For example, push places something on top of a stack. Pop is removing something from the top of the stack.\nIn code, you might imagine a stack as follows:\n\ntypedef struct\n{\n    person people[CAPACITY];\n    int size;\n}\nstack;\nNotice that an array called people is of type person. The CAPACITY is how high the stack could be. The integer size is how full the stack actually is, regardless of how much it could hold.\n\nYou might imagine that the above code has a limitation. Since the capacity of the array is always predetermined in this code. Therefore, the stack may always be oversized. You might imagine only using one place in the stack out of 5000.\nIt would be nice for our stack to be dynamic \u2013 able to grow as items are added to it.\nJack Learns the Facts\nWe watched a video called Jack Learns the Facts by Professor Shannon Duvall of Elon University.\nResizing Arrays\nRewinding to Week 2, we introduced you to your first data structure.\nAn array is a block of contiguous memory.\nYou might imagine an array as follows:\n\nthree boxes with 1 2 3\n\nIn memory, there are other values being stored by other programs, functions, and variables. Many of these may be unused garbage values that were utilized at one point but are available now for use.\n\nthree boxes with 1 2 3 among lots of other memory elements\n\nImagine you wanted to store a fourth value 4 in our array? What would be needed is to allocate a new area of memory and move the old array to a new one. Initially, this new area of memory would be populated with garbage values.\n\nThree boxes with 1 2 3 above four boxes with garbage values\n\nAs values are added to this new area of memory, old garbage values would be overwritten.\n\nThree boxes with 1 2 3 above four boxes with 1 2 3 and a garbage value\n\nEventually, all old garbage values would be overwritten with our new data.\n\nThree boxes with 1 2 3 above four boxes with 1 2 3 4\n\nOne of the drawbacks of this approach is that it\u2019s bad design: Every time we add a number, we have to copy the array item by item.\nWouldn\u2019t it be nice if we were able to put the 4 somewhere else in memory? By definition, this would no longer be an array because 4 would no longer be in contiguous memory.\nIn your terminal, type code list.c and write code as follows:\n\n// Implements a list of numbers with an array of fixed size\n\n#include <stdio.h>\n\nint main(void)\n{\n    // List of size 3\n    int list[3];\n\n    // Initialize list with numbers\n    list[0] = 1;\n    list[1] = 2;\n    list[2] = 3;\n\n    // Print list\n    for (int i = 0; i < 3; i++)\n    {\n        printf(\"%i\\n\", list[i]);\n    }\n}\nNotice that the above is very much like what we learned earlier in this course. We have memory being preallocated for three items.\n\nBuilding upon our knowledge obtained more recently, we can leverage our understanding of pointers to create a better design in this code. Modify your code as follows:\n\n// Implements a list of numbers with an array of dynamic size\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void)\n{\n    // List of size 3\n    int *list = malloc(3 * sizeof(int));\n    if (list == NULL)\n    {\n        return 1;\n    }\n\n    // Initialize list of size 3 with numbers\n    list[0] = 1;\n    list[1] = 2;\n    list[2] = 3;\n\n    // List of size 4\n    int *tmp = malloc(4 * sizeof(int));\n    if (tmp == NULL)\n    {\n        free(list);\n        return 1;\n    }\n\n    // Copy list of size 3 into list of size 4\n    for (int i = 0; i < 3; i++)\n    {\n        tmp[i] = list[i];\n    }\n\n    // Add number to list of size 4\n    tmp[3] = 4;\n\n    // Free list of size 3\n    free(list);\n\n    // Remember list of size 4\n    list = tmp;\n\n    // Print list\n    for (int i = 0; i < 4; i++)\n    {\n        printf(\"%i\\n\", list[i]);\n    }\n\n    // Free list\n    free(list);\n    return 0;\n}\nNotice that a list of size three integers is created. Then, three memory addresses can be assigned the values 1, 2, and 3. Then, a list of size four is created. Next, the list is copied from the first to the second. The value for the 4 is added to the tmp list. Since the block of memory that list points to is no longer used, it is freed using the command free(list). Finally, the compiler is told to point list pointer now to the block of memory that tmp points to. The contents of list are printed and then freed.\n\nIt\u2019s useful to think about list and tmp as both signs that point at a chunk of memory. As in the example above, list at one point pointed to an array of size 3. By the end, list was told to point to a chunk of memory of size 4. Technically, by the end of the above code, tmp and list both pointed to the same block of memory.\nOne may be tempted to allocate way more memory than required for the list, such as 30 items instead of the required 3 or 4. However, this is bad design as it taxes system resources when they are not potentially needed. Further, there is little guarantee that memory for more than 30 items will be needed eventually.\nLinked Lists\nIn recent weeks, you have learned about three useful primitives. A struct is a data type that you can define yourself. A . in dot notation allows you to access variables inside that structure. The * operator is used to declare a pointer or dereference a variable.\nToday, you are introduced to the -> operator. It is an arrow. This operator goes to an address and looks inside of a structure.\nA linked list is one of the most powerful data structures within C. A linked list allows you to include values that are located at varying areas of memory. Further, they allow you to dynamically grow and shrink the list as you desire.\nYou might imagine three values stored at three different areas of memory as follows:\n\nThree boxes with 1 2 3 in separate areas of memory\n\nHow could one stitch together these values in a list?\nWe could imagine this data pictured above as follows:\n\nThree boxes with 1 2 3 in separate areas of memory with smaller boxes attached\n\nWe could utilize more memory to keep track of where the next item is.\n\nThree boxes with 1 2 3 in separate areas of memory with smaller boxes attached where memory addresses are in those attached boxes\n\nNotice that NULL is utilized to indicate that nothing else is next in the list.\n\nBy convention, we would keep one more element in memory, a pointer, that keeps track of the first item in the list.\n\nThree boxes with 1 2 3 in separate areas of memory with smaller boxes attached where memory addresses are in those attached boxes now with a final box with the memory address of the first box\n\nAbstracting away the memory addresses, the list would appear as follows:\n\nThree boxes with in separate areas of memory with smaller boxes with a final box where the one box points to another and another until the end of the boxes\n\nThese boxes are called nodes. A node contains both an item and a pointer called next. In code, you can imagine a node as follows:\n\ntypedef struct node\n{\n    int number;\n    struct node *next;\n}\nnode;\nNotice that the item contained within this node is an integer called number. Second, a pointer to a node called next is included, which will point to another node somewhere in memory.\n\nConceptually, we can imagine the process of creating a linked list. First, node *list is declared, but it is of a garbage value.\n\nOne garbage value\n\nNext, a node called n is allocated in memory.\n\nOne garbage value called n with another pointer called list\n\nNext, the number of node is assigned the value 1.\n\nn pointing to a node with 1 as the number and garbage value as the next\n\nNext, the node\u2019s next field is assigned NULL.\n\nn pointing to a node with 1 as the number and null as the value of next\n\nNext, list is pointed at the memory location to where n points. n and list now point to the same place.\n\nn and list both pointing to a node with 1 as the number and null as the value of next\n\nA new node is then created. Both the number and next field are both filled with garbage values.\n\nlist pointing to a node with 1 as the number and null as the value of next and n pointing to a new node with garbage values\n\nThe number value of n\u2019s node (the new node) is updated to 2.\n\nlist pointing to a node with 1 as the number and null as the value of next and n pointing to a new node with 2 as the number and garbage as the next\n\nAlso, the next field is updated as well.\n\nlist pointing to a node with 1 as the number and null as the value of next and n pointing to a new node with 2 as the number and null as the next\n\nMost important, we do not want to lose our connection to any of these nodes lest they be lost forever. Accordingly, n\u2019s next field is pointed to the same memory location as list.\n\nlist pointing to a node with 1 as the number and null as the value of next and n pointing to a new node with 2 as the number and null as the next\n\nFinally, list is updated to point at n. We now have a linked list of two items.\n\nlist pointing to a node with 1 as the number and next pointing to a node with an n pointing the same place the node with one points to a node with 2 as the number and null as the next\n\nTo implement this in code, modify your code as follows:\n\n// Prepends numbers to a linked list, using while loop to print\n\n#include <cs50.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node\n{\n    int number;\n    struct node *next;\n}\nnode;\n\nint main(int argc, char *argv[])\n{\n    // Memory for numbers\n    node *list = NULL;\n\n    // For each command-line argument\n    for (int i = 1; i < argc; i++)\n    {\n        // Convert argument to int\n        int number = atoi(argv[i]);\n\n        // Allocate node for number\n        node *n = malloc(sizeof(node));\n        if (n == NULL)\n        {\n            return 1;\n        }\n        n->number = number;\n        n->next = NULL;\n\n        // Prepend node to list\n        n->next = list;\n        list = n;\n    }\n\n    // Print numbers\n    node *ptr = list;\n    while (ptr != NULL)\n    {\n        printf(\"%i\\n\", ptr->number);\n        ptr = ptr->next;\n    }\n\n    // Free memory\n    ptr = list;\n    while (ptr != NULL)\n    {\n        node *next = ptr->next;\n        free(ptr);\n        ptr = next;\n    }\n}\nNotice that what the user inputs at the command line is put into the number field of a node called n, and then that node is added to the list. For example, ./list 1 2 will put the number 1 into the number field of a node called n, then put a pointer to list into the next field of the node, and then update list to point to n. That same process is repeated for 2. Next, node *ptr = list creates a temporary variable that points at the same spot that list points to. The while prints what at the node ptr points to, and then updates ptr to point to the next node in the list. Finally, all the memory is freed.\n\nIn this example, inserting into the list is always in the order of \n, as it only takes a very small number of steps to insert at the front of a list.\nConsidering the amount of time required to search this list, it is in the order of \n, as in the worst case the entire list must always be searched to find an item. The time complexity for adding a new element to the list will depend on where that element is added. This is illustrated in the examples below.\nLinked lists are not stored in a contiguous block of memory. They can grow as large as you wish, provided that enough system resources exist. The downside, however, is that more memory is required to keep track of the list instead of an array. This is because for each element, you must store not just the value of the element, but also a pointer to the next node. Further, linked lists cannot be indexed into like is possible in an array because we need to pass through the first \n elements to find the location of the \nth element. Because of this, the list pictured above must be linearly searched. Binary search, therefore, is not possible in a list constructed as above.\nFurther, you could place numbers at the end of the list as illustrated in this code:\n\n// Implements a list of numbers using a linked list\n\n#include <cs50.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node\n{\n    int number;\n    struct node *next;\n}\nnode;\n\nint main(int argc, char *argv[])\n{\n    // Memory for numbers\n    node *list = NULL;\n\n    // For each command-line argument\n    for (int i = 1; i < argc; i++)\n    {\n        // Convert argument to int\n        int number = atoi(argv[i]);\n\n        // Allocate node for number\n        node *n = malloc(sizeof(node));\n        if (n == NULL)\n        {\n            return 1;\n        }\n        n->number = number;\n        n->next = NULL;\n\n        // If list is empty\n        if (list == NULL)\n        {\n            // This node is the whole list\n            list = n;\n        }\n\n        // If list has numbers already\n        else\n        {\n            // Iterate over nodes in list\n            for (node *ptr = list; ptr != NULL; ptr = ptr->next)\n            {\n                // If at end of list\n                if (ptr->next == NULL)\n                {\n                    // Append node\n                    ptr->next = n;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Print numbers\n    for (node *ptr = list; ptr != NULL; ptr = ptr->next)\n    {\n        printf(\"%i\\n\", ptr->number);\n    }\n\n    // Free memory\n    node *ptr = list;\n    while (ptr != NULL)\n    {\n        node *next = ptr->next;\n        free(ptr);\n        ptr = next;\n    }\n}\nNotice how this code walks down this list to find the end. When appending an element, (adding to the end of the list) our code will run in \n, as we have to go through our entire list before we can add the final element.\n\nFurther, you could sort your list as items are added:\n\n// Implements a sorted list of numbers using a linked list\n\n#include <cs50.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node\n{\n    int number;\n    struct node *next;\n}\nnode;\n\nint main(int argc, char *argv[])\n{\n    // Memory for numbers\n    node *list = NULL;\n\n    // For each command-line argument\n    for (int i = 1; i < argc; i++)\n    {\n        // Convert argument to int\n        int number = atoi(argv[i]);\n\n        // Allocate node for number\n        node *n = malloc(sizeof(node));\n        if (n == NULL)\n        {\n            return 1;\n        }\n        n->number = number;\n        n->next = NULL;\n\n        // If list is empty\n        if (list == NULL)\n        {\n            list = n;\n        }\n\n        // If number belongs at beginning of list\n        else if (n->number < list->number)\n        {\n            n->next = list;\n            list = n; \n        }\n\n        // If number belongs later in list\n        else\n        {\n            // Iterate over nodes in list\n            for (node *ptr = list; ptr != NULL; ptr = ptr->next)\n            {\n                // If at end of list\n                if (ptr->next == NULL)\n                {\n                    // Append node\n                    ptr->next = n;\n                    break;\n                }\n\n                // If in middle of list\n                if (n->number < ptr->next->number)\n                {\n                    n->next = ptr->next;\n                    ptr->next = n;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Print numbers\n    for (node *ptr = list; ptr != NULL; ptr = ptr->next)\n    {\n        printf(\"%i\\n\", ptr->number);\n    }\n\n    // Free memory\n    node *ptr = list;\n    while (ptr != NULL)\n    {\n        node *next = ptr->next;\n        free(ptr);\n        ptr = next;\n    }\n}\nNotice how this list is sorted as it is built. To insert an element in this specific order, our code will still run in \n for each insertion, as in the worst case we will have to look through all current elements.\n\nTrees\nBinary search trees are another data structure that can be used to store data more efficiently such that it can be searched and retrieved.\nYou can imagine a sorted sequence of numbers.\n\n1 2 3 4 5 6 7 in boxes next to each other\n\nImagine then that the center value becomes the top of a tree. Those that are less than this value are placed to the left. Those values that are more than this value are to the right.\n\n1 2 3 4 5 6 7 in boxes arranged in a hierarchy 4 is at the top 3 and 5 are below that and 1 2 6 7 are below those\n\nPointers can then be used to point to the correct location of each area of memory such that each of these nodes can be connected.\n\n1 2 3 4 5 6 7 in boxes arranged in a hierarchy 4 is at the top 3 and 5 are below that and 1 2 6 7 are below those arrows connect them in a tree formation\n\nIn code, this can be implemented as follows.\n\n// Implements a list of numbers as a binary search tree\n\n#include <stdio.h>\n#include <stdlib.h>\n\n// Represents a node\ntypedef struct node\n{\n    int number;\n    struct node *left;\n    struct node *right;\n}\nnode;\n\nvoid free_tree(node *root);\nvoid print_tree(node *root);\n\nint main(void)\n{\n    // Tree of size 0\n    node *tree = NULL;\n\n    // Add number to list\n    node *n = malloc(sizeof(node));\n    if (n == NULL)\n    {\n        return 1;\n    }\n    n->number = 2;\n    n->left = NULL;\n    n->right = NULL;\n    tree = n;\n\n    // Add number to list\n    n = malloc(sizeof(node));\n    if (n == NULL)\n    {\n        free_tree(tree);\n        return 1;\n    }\n    n->number = 1;\n    n->left = NULL;\n    n->right = NULL;\n    tree->left = n;\n\n    // Add number to list\n    n = malloc(sizeof(node));\n    if (n == NULL)\n    {\n        free_tree(tree);\n        return 1;\n    }\n    n->number = 3;\n    n->left = NULL;\n    n->right = NULL;\n    tree->right = n;\n\n    // Print tree\n    print_tree(tree);\n\n    // Free tree\n    free_tree(tree);\n    return 0;\n}\n\nvoid free_tree(node *root)\n{\n    if (root == NULL)\n    {\n        return;\n    }\n    free_tree(root->left);\n    free_tree(root->right);\n    free(root);\n}\n\nvoid print_tree(node *root)\n{\n    if (root == NULL)\n    {\n        return;\n    }\n    print_tree(root->left);\n    printf(\"%i\\n\", root->number);\n    print_tree(root->right);\n}\nNotice this search function begins by going to the location of tree. Then, it uses recursion to search for number. The free_tree function recursively frees the tree. print_tree recursively prints the tree.\n\nA tree like the above offers dynamism that an array does not offer. It can grow and shrink as we wish.\nFurther, this structure offers a search time of \n.\nDictionaries\nDictionaries are another data structure.\nDictionaries, like actual book-form dictionaries that have a word and a definition, have a key and a value.\nThe holy grail of algorithmic time complexity is \n or constant time. That is, the ultimate is for access to be instantaneous.\n\na graph of various time comlexities where O of log n is second best and O of 1 is best\n\nDictionaries can offer this speed of access through hashing.\nHashing and Hash Tables\nHashing is the idea of taking a value and being able to output a value that becomes a shortcut to it later.\nFor example, hashing apple may hash as a value of 1, and berry may be hashed as 2. Therefore, finding apple is as easy as asking the hash algorithm where apple is stored. While not ideal in terms of design, ultimately, putting all a\u2019s in one bucket and b\u2019s in another, this concept of bucketizing hashed values illustrates how you can use this concept: a hashed value can be used to shortcut finding such a value.\nA hash function is an algorithm that reduces a larger value to something small and predictable. Generally, this function takes in an item you wish to add to your hash table, and returns an integer representing the array index in which the item should be placed.\nA hash table is a fantastic combination of both arrays and linked lists. When implemented in code, a hash table is an array of pointers to nodes.\nA hash table could be imagined as follows:\n\na verticle column of 26 boxes one for each letter of the alphabet\n\nNotice that this is an array that is assigned each value of the alphabet.\n\nThen, at each location of the array, a linked list is used to track each value being stored there:\n\na verticle column of 26 boxes one for each letter of the alphabet with various names from themario unverise emerging to the right luigi is with l and mario is with m\n\nCollisions are when you add values to the hash table, and something already exists at the hashed location. In the above, collisions are simply appended to the end of the list.\nCollisions can be reduced by better programming your hash table and hash algorithm. You can imagine an improvement upon the above as follows:\n\na verticle column of various boxeds arranged by L A K and L I N with lakitu emerging from L A K and link emerging from L I N\n\nConsider the following example of a hash algorithm:\n\nluigi being given to a hash algorithm outputting 11\n\nThis could be implemented in code as:\n\n#include <ctype.h>\n\nunsigned int hash(const char *word)\n{\n    return toupper(word[0]) - 'A';\n}\n\nNotice how the hash function returns the value of toupper(word[0]) - 'A'.\n\nYou, as the programmer, have to make a decision about the advantages of using more memory to have a large hash table and potentially reducing search time or using less memory and potentially increasing search time.\nTries\nTries are another form of data structure.\nTries are always searchable in constant time.\nOne downside to Tries is that they tend to take up a large amount of memory. Notice that we need \n nodes just to store Toad!\nToad would be stored as follows:\n\ntoad being spelled with one letter at a time where one letter is associated with one list T from one list O from another and so on \n\nTom would then be stored as follows:\n\ntoad being spelled with one letter at a time where one letter is associated with one list T from one list O from another and so on and tom being spelled similarly where toad and tom share a two common letters T and O\n\nThe downside of this structure is how many resources are required to use it.\nSumming Up\nIn this lesson, you learned about using pointers to build new data structures. Specifically, we delved into\u2026\n\nData structures\nStacks and queues\nResizing arrays\nLinked lists\nDictionaries\nTries\nSee you next time!"
        },
        {
            "lecture": 4,
            "content": "Lecture 4\nWelcome!\nPixel Art\nHexadecimal\nMemory\nPointers\nStrings\nPointer Arithmetic\nString Comparison\nCopying\nmalloc and Valgrind\nGarbage Values\nPointer Fun with Binky\nSwap\nOverflow\nscanf\nFile I/O\nSumming Up\nWelcome!\nIn previous weeks, we talked about images being made of smaller building blocks called pixels.\nToday, we will go into further detail about the zeros and ones that make up these images. In particular, we will be going deeper into the fundamental building blocks that make up files, including images.\nFurther, we will discuss how to access the underlying data stored in computer memory.\nPixel Art\nPixels are squares, individual dots, of color that are arranged on an up-down, left-right grid.\nYou can imagine as an image as a map of bits, where zeros represent black and ones represent white.\n\nZeros and ones being converted to a black and white smiley\n\nRGB, or red, green, blue, are numbers that represent the amount of each of these colors. In Adobe Photoshop, you can see these settings as follows:\n\nA photoshop panel with RGB values and hexidecimal input\n\nNotice how the amount of red, blue, and green changes the color selected.\n\nYou can see by the image above that color is not just represented in three values. At the bottom of the window, there is a special value made up of numbers and characters. 255 is represented as FF. Why might this be?\nHexadecimal\nHexadecimal is a system of counting that has 16 counting values. They are as follows:\n\n  0 1 2 3 4 5 6 7 8 9 a b c d e f\nNotice that F represents 15.\n\nHexadecimal is also known as base-16.\nWhen counting in hexadecimal, each column is a power of 16.\nThe number 0 is represented as 00.\nThe number 1 is represented as 01.\nThe number 9 is represented by 09.\nThe number 10 is represented as 0A.\nThe number 15 is represented as 0F.\nThe number 16 is represented as 10.\nThe number 255 is represented as FF, because 16 x 15 (or F) is 240. Add 15 more to make 255. This is the highest number you can count using a two-digit hexadecimal system.\nHexadecimal is useful because it can be represented using fewer digits. Hexadecimal allows us to represent information more succinctly.\nMemory\nIn weeks past, you may recall our artist rendering of concurrent blocks of memory. Applying hexadecimal numbering to each of these blocks of memory, you can visualize these as follows:\n\nBlocks of memory numbered in hex\n\nYou can imagine how there may be confusion regarding whether the 10 block above may represent a location in memory or the value 10. Accordingly, by convention, all hexadecimal numbers are often represented with the 0x prefix as follows:\n\nblocks of memory numbered in hex with 0x\n\nIn your terminal window, type code addresses.c and write your code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    int n = 50;\n    printf(\"%i\\n\", n);\n}\nNotice how n is stored in memory with the value 50.\n\nYou can visualize how this program stores this value as follows:\n\nthe value 50 stored in a memory location with hex\n\nThe C language has two powerful operators that relate to memory:\n\n  & Provides the address of something stored in memory.\n  * Instructs the compiler to go to a location in memory.\nWe can leverage this knowledge by modifying our code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    int n = 50;\n    printf(\"%p\\n\", &n);\n}\nNotice the %p, which allows us to view the address of a location in memory. &n can be literally translated as \u201cthe address of n.\u201d Executing this code will return an address of memory beginning with 0x.\n\nPointers\nA pointer is a variable that contains the address of some value. Most succinctly, a pointer is an address in your computer\u2019s memory.\nConsider the following code:\n\nint n = 50;\n\nint *p = &n;\nNotice that p is a pointer that contains the address of an integer n.\n\nModify your code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    int n = 50;\n    int *p = &n;\n    printf(\"%p\\n\", p);\n}\nNotice that this code has the same effect as our previous code. We have simply leveraged our new knowledge of the & and * operators.\n\nTo illustrate the use of the * operator, consider the following:\n\n#include <stdio.h>\n\nint main(void)\n{\n    int n = 50;\n    int *p = &n;\n    printf(\"%i\\n\", *p);\n}\nNotice that the printf line prints the integer at the location of p. int *p creates a pointer whose job is to store the memory address of an integer.\n\nYou can visualize our code as follows:\n\nSame value of 50 in a memory location with a pointer value stored elsewhere\n\nNotice the pointer seems rather large. Indeed, a pointer is usually stored as an 8-byte value. p is storing the address of the 50.\n\nYou can more accurately visualize a pointer as one address that points to another:\n\nA pointer as an arrow, pointing from one location of memory to another\n\nStrings\nNow that we have a mental model for pointers, we can peel back a level of simplification that was offered earlier in this course.\nRecall that a string is simply an array of characters. For example, string s = \"HI!\" can be represented as follows:\n\nThe string HI with an exclaimation point stored in memory\n\nHowever, what is s really? Where is the s stored in memory? As you can imagine, s needs to be stored somewhere. You can visualize the relationship of s to the string as follows:\n\nSame string HI with a pointer pointing to it\n\nNotice how a pointer called s tells the compiler where the first byte of the string exists in memory.\n\nModify your code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    string s = \"HI!\";\n    printf(\"%p\\n\", s);\n    printf(\"%p\\n\", &s[0]);\n    printf(\"%p\\n\", &s[1]);\n    printf(\"%p\\n\", &s[2]);\n    printf(\"%p\\n\", &s[3]);\n}\nNotice the above prints the memory locations of each character in the string s. The & symbol is used to show the address of each element of the string. When running this code, notice that elements 0, 1, 2, and 3 are next to one another in memory.\n\nLikewise, you can modify your code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    char *s = \"HI!\";\n    printf(\"%s\\n\", s);\n}\nNotice that this code will present the string that starts at the location of s. This code effectively removes the training wheels of the string data type offered by cs50.h. This is raw C code, without the scaffolding of the cs50 library.\n\nYou can imagine how a string, as a data type, is created.\nLast week, we learned how to create your own data type as a struct.\nThe cs50 library includes a struct as follows: typedef char *string\nThis struct, when using the cs50 library, allows one to use a custom data type called string.\nPointer Arithmetic\nYou can modify your code to accomplish the same thing in a longer form as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    char *s = \"HI!\";\n    printf(\"%c\\n\", s[0]);\n    printf(\"%c\\n\", s[1]);\n    printf(\"%c\\n\", s[2]);\n}\nNotice that we are printing each character at the location of s.\n\nFurther, you can modify your code as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    char *s = \"HI!\";\n    printf(\"%c\\n\", *s);\n    printf(\"%c\\n\", *(s + 1));\n    printf(\"%c\\n\", *(s + 2));\n}\nNotice that the first character at the location of s is printed. Then, the character at the location s + 1 is printed, and so on.\n\nString Comparison\nA string of characters is simply an array of characters identified by its first byte.\nEarlier in the course, we considered the comparison of integers. We could represent this in code by typing code compare.c into the terminal window and writing code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // Get two integers\n    int i = get_int(\"i: \");\n    int j = get_int(\"j: \");\n\n    // Compare integers\n    if (i == j)\n    {\n        printf(\"Same\\n\");\n    }\n    else\n    {\n        printf(\"Different\\n\");\n    }\n}\nNotice that this code takes two integers from the user and compares them.\n\nIn the case of strings, however, one cannot compare two strings using the == operator.\nUtilizing the == operator in an attempt to compare strings will attempt to compare the memory locations of the strings instead of the characters therein. Accordingly, we recommended the use of strcmp.\nTo illustrate this, modify your code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // Get two strings\n    char *s = get_string(\"s: \");\n    char *t = get_string(\"t: \");\n\n    // Compare strings' addresses\n    if (s == t)\n    {\n        printf(\"Same\\n\");\n    }\n    else\n    {\n        printf(\"Different\\n\");\n    }\n}\nNoticing that typing in HI! for both strings still results in the output of Different.\n\nWhy are these strings seemingly different? You can use the following to visualize why:\n\ntwo strings stored separately in memory\n\nTherefore, the code for compare.c above is actually attempting to see if the memory addresses are different: not the strings themselves.\nUsing strcmp, we can correct our code:\n\n#include <cs50.h>\n#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    // Get two strings\n    char *s = get_string(\"s: \");\n    char *t = get_string(\"t: \");\n\n    // Compare strings\n    if (strcmp(s, t) == 0)\n    {\n        printf(\"Same\\n\");\n    }\n    else\n    {\n        printf(\"Different\\n\");\n    }\n}\nNotice that strcmp can return 0 if the strings are the same.\n\nTo further illustrate how these two strings are living in two locations, modify your code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // Get two strings\n    char *s = get_string(\"s: \");\n    char *t = get_string(\"t: \");\n\n    // Print strings\n    printf(\"%s\\n\", s);\n    printf(\"%s\\n\", t);\n}\nNotice how we now have two separate strings stored likely at two separate locations.\n\nYou can see the locations of these two stored strings with a small modification:\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // Get two strings\n    char *s = get_string(\"s: \");\n    char *t = get_string(\"t: \");\n\n    // Print strings' addresses\n    printf(\"%p\\n\", s);\n    printf(\"%p\\n\", t);\n}\nNotice that the %s has been changed to %p in the print statement.\n\nCopying\nA common need in programming is to copy one string to another.\nIn your terminal window, type code copy.c and write code as follows:\n\n#include <cs50.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    // Get a string\n    string s = get_string(\"s: \");\n\n    // Copy string's address\n    string t = s;\n\n    // Capitalize first letter in string\n    t[0] = toupper(t[0]);\n\n    // Print string twice\n    printf(\"s: %s\\n\", s);\n    printf(\"t: %s\\n\", t);\n}\nNotice that string t = s copies the address of s to t. This does not accomplish what we are desiring. The string is not copied \u2013 only the address is.\n\nYou can visualize the above code as follows:\n\ntwo pointers pointing at the same memory location with a string\n\nNotice that s and t are still pointing at the same blocks of memory. This is not an authentic copy of a string. Instead, these are two pointers pointing at the same string.\n\nBefore we address this challenge, it\u2019s important to ensure that we don\u2019t experience a segmentation fault through our code, where we attempt to copy string s to string t, where string t does not exist. We can employ the strlen function as follows to assist with that:\n\n#include <cs50.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    // Get a string\n    string s = get_string(\"s: \");\n\n    // Copy string's address\n    string t = s;\n\n    // Capitalize first letter in string\n    if (strlen(t) > 0)\n    {\n        t[0] = toupper(t[0]);\n    }\n\n    // Print string twice\n    printf(\"s: %s\\n\", s);\n    printf(\"t: %s\\n\", t);\n}\nNotice that strlen is used to make sure string t exists. If it does not, nothing will be copied.\n\nTo be able to make an authentic copy of the string, we will need to introduce two new building blocks. First, malloc allows you, the programmer, to allocate a block of a specific size of memory. Second, free allows you to tell the compiler to free up that block of memory you previously allocated.\n\nWe can modify our code to create an authentic copy of our string as follows:\n\n#include <cs50.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(void)\n{\n    // Get a string\n    char *s = get_string(\"s: \");\n\n    // Allocate memory for another string\n    char *t = malloc(strlen(s) + 1);\n\n    // Copy string into memory, including '\\0'\n    for (int i = 0; i <= strlen(s); i++)\n    {\n        t[i] = s[i];\n    }\n\n    // Capitalize copy\n    t[0] = toupper(t[0]);\n\n    // Print strings\n    printf(\"s: %s\\n\", s);\n    printf(\"t: %s\\n\", t);\n}\nNotice that malloc(strlen(s) + 1) creates a block of memory that is the length of the string s plus one. This allows for the inclusion of the null \\0 character in our final, copied string. Then, the for loop walks through the string s and assigns each value to that same location on the string t.\n\nIt turns out that there is an inefficiency in our code. Modify your code as follows:\n\n#include <cs50.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(void)\n{\n    // Get a string\n    char *s = get_string(\"s: \");\n\n    // Allocate memory for another string\n    char *t = malloc(strlen(s) + 1);\n\n    // Copy string into memory, including '\\0'\n    for (int i = 0, n = strlen(s); i <= n; i++)\n    {\n        t[i] = s[i];\n    }\n\n    // Capitalize copy\n    t[0] = toupper(t[0]);\n\n    // Print strings\n    printf(\"s: %s\\n\", s);\n    printf(\"t: %s\\n\", t);\n}\nNotice that n = strlen(s) is defined now in the left-hand side of the for loop. It\u2019s best not to call unneeded functions in the middle condition of the for loop, as it will run over and over again. When moving n = strlen(s) to the left-hand side, the function strlen only runs once.\n\nThe C Language has a built-in function to copy strings called strcpy. It can be implemented as follows:\n\n#include <cs50.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(void)\n{\n    // Get a string\n    char *s = get_string(\"s: \");\n\n    // Allocate memory for another string\n    char *t = malloc(strlen(s) + 1);\n\n    // Copy string into memory\n    strcpy(t, s);\n\n    // Capitalize copy\n    t[0] = toupper(t[0]);\n\n    // Print strings\n    printf(\"s: %s\\n\", s);\n    printf(\"t: %s\\n\", t);\n}\nNotice that strcpy does the same work that our for loop previously did.\n\nBoth get_string and malloc return NULL, a special value in memory, in the event that something goes wrong. You can write code that can check for this NULL condition as follows:\n\n#include <cs50.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(void)\n{\n    // Get a string\n    char *s = get_string(\"s: \");\n    if (s == NULL)\n    {\n        return 1;\n    }\n\n    // Allocate memory for another string\n    char *t = malloc(strlen(s) + 1);\n    if (t == NULL)\n    {\n        return 1;\n    }\n\n    // Copy string into memory\n    strcpy(t, s);\n\n    // Capitalize copy\n    if (strlen(t) > 0)\n    {\n        t[0] = toupper(t[0]);\n    }\n\n    // Print strings\n    printf(\"s: %s\\n\", s);\n    printf(\"t: %s\\n\", t);\n\n    // Free memory\n    free(t);\n    return 0;\n}\nNotice that if the string obtained is of length 0 or malloc fails, NULL is returned. Further, notice that free lets the computer know you are done with this block of memory you created via malloc.\n\nmalloc and Valgrind\nValgrind is a tool that can check to see if there are memory-related issues with your programs wherein you utilized malloc. Specifically, it checks to see if you free all the memory you allocated.\nConsider the following code for memory.c:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void)\n{\n    int *x = malloc(3 * sizeof(int));\n    x[1] = 72;\n    x[2] = 73;\n    x[3] = 33;\n}\nNotice that running this program does not cause any errors. While malloc is used to allocate enough memory for an array, the code fails to free that allocated memory.\n\nIf you type make memory followed by valgrind ./memory, you will get a report from valgrind that will report where memory has been lost as a result of your program. One error that valgrind reveals is that we attempted to assign the value of 33 at the 4th position of the array, where we only allocated an array of size 3. Another error is that we never freed x.\nYou can modify your code as follows:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void)\n{\n    int *x = malloc(3 * sizeof(int));\n    x[0] = 72;\n    x[1] = 73;\n    x[2] = 33;\n    free(x);\n}\nNotice that running valgrind again now results in no memory leaks.\n\nGarbage Values\nWhen you ask the compiler for a block of memory, there is no guarantee that this memory will be empty.\nIt\u2019s very possible that this memory that you allocated was previously utilized by the computer. Accordingly, you may see junk or garbage values. This is a result of you getting a block of memory but not initializing it. For example, consider the following code for garbage.c:\n\n#include <stdio.h>\n\nint main(void)\n{\n    int scores[1024];\n    for (int i = 0; i < 1024; i++)\n    {\n        printf(\"%i\\n\", scores[i]);\n    }\n}\nNotice that running this code will allocate 1024 locations in memory for your array, but the for loop will likely show that not all values therein are 0. It\u2019s always best practice to be aware of the potential for garbage values when you do not initialize blocks of memory to some other value like zero or otherwise.\n\nPointer Fun with Binky\nWe watched a video from Stanford University that helped us visualize and understand pointers.\nSwap\nIn the real world, a common need in programming is to swap two values. Naturally, it\u2019s hard to swap two variables without a temporary holding space. In practice, you can type code swap.c and write code as follows to see this in action:\n\n#include <stdio.h>\n\nvoid swap(int a, int b);\n\nint main(void)\n{\n    int x = 1;\n    int y = 2;\n\n    printf(\"x is %i, y is %i\\n\", x, y);\n    swap(x, y);\n    printf(\"x is %i, y is %i\\n\", x, y);\n}\n\nvoid swap(int a, int b)\n{\n    int tmp = a;\n    a = b;\n    b = tmp;\n}\nNotice that while this code runs, it does not work. The values, even after being sent to the swap function, do not swap. Why?\n\nWhen you pass values to a function, you are only providing copies. In previous weeks, we discussed the concept of scope. The values of x and y created in the curly {} braces of the main function only have the scope of the main function. Consider the following image:\n\na rectangle with machine code at top followed by globals heap and stack\n\nNotice that global variables, which we have not used in this course, live in one place in memory. Various functions are stored in the stack in another area of memory.\n\nNow, consider the following image:\n\na rectangle with main function at bottom and swap function directly above it\n\nNotice that main and swap have two separate frames or areas of memory. Therefore, we cannot simply pass the values from one function to another to change them.\n\nModify your code as follows:\n\n#include <stdio.h>\n\nvoid swap(int *a, int *b);\n\nint main(void)\n{\n    int x = 1;\n    int y = 2;\n\n    printf(\"x is %i, y is %i\\n\", x, y);\n    swap(&x, &y);\n    printf(\"x is %i, y is %i\\n\", x, y);\n}\n\nvoid swap(int *a, int *b)\n{\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\nNotice that variables are not passed by value but by reference. That is, the addresses of a and b are provided to the function. Therefore, the swap function can know where to make changes to the actual a and b from the main function.\n\nYou can visualize this as follows:\n\na and b stored in main function being passed by reference to the swap function\n\nOverflow\nA heap overflow is when you overflow the heap, touching areas of memory you are not supposed to.\nA stack overflow is when too many functions are called, overflowing the amount of memory available.\nBoth of these are considered buffer overflows.\nscanf\nIn CS50, we have created functions like get_int to simplify the act of getting input from the user.\nscanf is a built-in function that can get user input.\nWe can reimplement get_int rather easily using scanf as follows:\n\n#include <stdio.h>\n\nint main(void)\n{\n    int x;\n    printf(\"x: \");\n    scanf(\"%i\", &x);\n    printf(\"x: %i\\n\", x);\n}\nNotice that the value of x is stored at the location of x in the line scanf(\"%i\", &x).\n\nHowever, attempting to reimplement get_string is not easy. Consider the following:\n\n#include <stdio.h>\n\nint main(void)\n{\n    char *s;\n    printf(\"s: \");\n    scanf(\"%s\", s);\n    printf(\"s: %s\\n\", s);\n}\nNotice that no & is required because strings are special. Still, this program will not function. Nowhere in this program do we allocate the amount of memory required for our string. Indeed, we don\u2019t know how long of a string may be inputted by the user!\n\nFurther, your code could be modified as follows. However, we have to pre-allocate a certain amount of memory for a string:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void)\n{\n    char *s = malloc(4);\n    if (s == NULL)\n    {\n        return 1;\n    }\n    printf(\"s: \");\n    scanf(\"%s\", s);\n    printf(\"s: %s\\n\", s);\n    free(s);\n    return 0;\n}\nNotice that if a string that is six bytes is provided you might get an error.\n\nSimplifying our code as follows we can further understand this essential problem of pre-allocation:\n\n#include <stdio.h>\n\nint main(void)\n{\n    char s[4];\n    printf(\"s: \");\n    scanf(\"%s\", s);\n    printf(\"s: %s\\n\", s);\n}\nNotice that if we pre-allocate an array of size 4, we can type cat and the program functions. However, a string larger than this could create an error.\n\nSometimes, the compiler or the system running it may allocate more memory than we indicate. Fundamentally, though, the above code is unsafe. We cannot trust that the user will input a string that fits into our pre-allocated memory.\nFile I/O\nYou can read from and manipulate files. While this topic will be discussed further in a future week, consider the following code for phonebook.c:\n\n#include <cs50.h>\n#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    // Open CSV file\n    FILE *file = fopen(\"phonebook.csv\", \"a\");\n\n    // Get name and number\n    char *name = get_string(\"Name: \");\n    char *number = get_string(\"Number: \");\n\n    // Print to file\n    fprintf(file, \"%s,%s\\n\", name, number);\n\n    // Close file\n    fclose(file);\n}\nNotice that this code uses pointers to access the file.\n\nYou can create a file called phonebook.csv in advance of running the above code. After running the above program and inputting a name and phone number, you will notice that this data persists in your CSV file.\nIf we want to ensure that phonebook.csv exists prior to running the program, we can modify our code as follows:\n\n#include <cs50.h>\n#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    // Open CSV file\n    FILE *file = fopen(\"phonebook.csv\", \"a\");\n    if (!file)\n    {\n        return 1;\n    }\n\n    // Get name and number\n    char *name = get_string(\"Name: \");\n    char *number = get_string(\"Number: \");\n\n    // Print to file\n    fprintf(file, \"%s,%s\\n\", name, number);\n\n    // Close file\n    fclose(file);\n}\nNotice that this program protects against a NULL pointer by invoking return 1.\n\nWe can implement our own copy program by typing code cp.c and writing code as follows:\n\n#include <stdio.h>\n#include <stdint.h>\n\ntypedef uint8_t BYTE;\n\nint main(int argc, char *argv[])\n{\n    FILE *src = fopen(argv[1], \"rb\");\n    FILE *dst = fopen(argv[2], \"wb\");\n\n    BYTE b;\n\n    while (fread(&b, sizeof(b), 1, src) !=0)\n    {\n        fwrite(&b, sizeof(b), 1, dst);\n    }\n\n    fclose(dst);\n    fclose(src);\n}\nNotice that this file creates our own data type called a BYTE that is the size of a uint8_t. Then, the file reads a BYTE and writes it to a file.\n\nBMPs are also assortments of data that we can examine and manipulate. This week, you will be doing just that in your problem sets!\nSumming Up\nIn this lesson, you learned about pointers that provide you with the ability to access and manipulate data at specific memory locations. Specifically, we delved into\u2026\n\nPixel art\nHexadecimal\nMemory\nPointers\nStrings\nPointer Arithmetic\nString Comparison\nCopying\nmalloc and Valgrind\nGarbage values\nSwapping\nOverflow\nscanf\nFile I/O\nSee you next time!"
        },
        {
            "lecture": 6,
            "content": "Lecture 6\nWelcome!\nPython\nHello\nSpeller\nFilter\nCS50 Library\nStrings\nVariables\nTypes\nCalculator\nConditionals\nObject-Oriented Programming\nLoops\nAbstraction\nTruncation and Floating Point Imprecision\nExceptions\nMario\nLists\nSearching and Dictionaries\nCommand-Line Arguments\nExit Status\nThird-Party Libraries\nSumming Up\nWelcome!\nIn previous weeks, you were introduced to the fundamental building blocks of programming.\nYou learned about programming in a lower-level programming language called C.\nToday, we are going to work with a higher-level programming language called Python.\nAs you learn this new language, you\u2019re going to find that you are going to be more able to teach yourself new programming languages.\nPython\nHumans, over the decades, have seen how previous design decisions could be improved upon.\nPython is a programming language that builds upon what you have already learned in C.\nUnlike in C, Python is an interpreted language, where you need not separately compile your program. Instead, you run your program in the Python Interpreter.\nHello\nUp until this point, the code has looked like this:\n\n// A program that says hello to the world\n\n#include <stdio.h>\n\nint main(void)\n{\n    printf(\"hello, world\\n\");\n}\nToday, you\u2019ll find that the process of writing and compiling code has been simplified.\nFor example, the above code will be rendered in Python as:\n\n# A program that says hello to the world\n\nprint(\"hello, world\")\nNotice that the semicolon is gone and that no library is needed.\n\nPython notably can implement what was quite complicated in C with relative simplicity.\nSpeller\nTo illustrate this simplicity, let\u2019s type \u2018code dictionary.py\u2019 in the terminal window and write code as follows:\n\n# Words in dictionary\nwords = set()\n\n\ndef check(word):\n    \"\"\"Return true if word is in dictionary else false\"\"\"\n    return word.lower() in words\n\n\ndef load(dictionary):\n    \"\"\"Load dictionary into memory, returning true if successful else false\"\"\"\n    with open(dictionary) as file:\n        words.update(file.read().splitlines())\n    return True\n\n\ndef size():\n    \"\"\"Returns number of words in dictionary if loaded else 0 if not yet loaded\"\"\"\n    return len(words)\n\n\ndef unload():\n    \"\"\"Unloads dictionary from memory, returning true if successful else false\"\"\"\n    return True\nNotice that there are four functions above. In the check function, if a word is in words, it returns True. So much easier than an implementation in C! Similarly, in the load function the dictionary file is opened. For each line in that file, we add that line to words. Using rstrip, the trailing new line is removed from the added word. size simply returns the len or length of words. unload only needs to return True because Python handles memory management on its own.\n\nThe above code illustrates why higher-level languages exist: To simplify and allow you to write code more easily.\nHowever, speed is a tradeoff. Because C allows you, the programmer, to make decisions about memory management, it may run faster than Python \u2013 depending on your code. While C only runs your lines of code, Python runs all the code that comes under the hood with it when you call Python\u2019s built-in functions.\nYou can learn more about functions in the Python documentation\nFilter\nTo further illustrate this simplicity, create a new file by typing code blur.py in your terminal window and write code as follows:\n\n# Blurs an image\n\nfrom PIL import Image, ImageFilter\n\n# Blur image\nbefore = Image.open(\"bridge.bmp\")\nafter = before.filter(ImageFilter.BoxBlur(1))\nafter.save(\"out.bmp\")\nNotice that this program imports modules Image and ImageFilter from a library called PIL. This takes an input file and creates and output file.\n\nFurther, you can create a new file called edges.py as follows:\n\n# Finds edges in an image\n\nfrom PIL import Image, ImageFilter\n\n# Find edges\nbefore = Image.open(\"bridge.bmp\")\nafter = before.filter(ImageFilter.FIND_EDGES)\nafter.save(\"out.bmp\")\nNotice that this code is a small adjustment to your blur code, but produces a dramatically different result.\n\nFinally, you can even do face detection as follows:\n\n# Find faces in picture\n# https://github.com/ageitgey/face_recognition/blob/master/examples/find_faces_in_picture.py\n\nfrom PIL import Image\nimport face_recognition\n\n# Load the jpg file into a numpy array\nimage = face_recognition.load_image_file(\"office.jpg\")\n\n# Find all the faces in the image using the default HOG-based model.\n# This method is fairly accurate, but not as accurate as the CNN model and not GPU accelerated.\n# See also: find_faces_in_picture_cnn.py\nface_locations = face_recognition.face_locations(image)\n\nfor face_location in face_locations:\n\n    # Print the location of each face in this image\n    top, right, bottom, left = face_location\n\n    # You can access the actual face itself like this:\n    face_image = image[top:bottom, left:right]\n    pil_image = Image.fromarray(face_image)\n    pil_image.show()\nNotice how this file uses a third-party library called face_recognition. This is enabled by running pip install face_recognition in one\u2019s terminal window.\n\nPython allows you to abstract away programming that would be much more complicated within C and other lower-level programming languages.\n\nCS50 Library\nAs with C, the CS50 library can be utilized within Python.\nThe following functions will be of particular use:\n\n  get_float\n  get_int\n  get_string\nYou also have the option of importing only specific functions from the CS50 library as follows:\n\nfrom CS50 import get_float, get_int, get_string\nStrings\nIn C, you might remember this code:\n\n// get_string and printf with %s\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    string answer = get_string(\"What's your name? \");\n    printf(\"hello, %s\\n\", answer);\n}\nThis code is transformed in Python to:\n\n# get_string and print, with concatenation\n\nfrom cs50 import get_string\n\nanswer = get_string(\"What's your name? \")\nprint(\"hello, \" + answer)\nYou can write this code by executing code hello.py in the terminal window. Then, you can execute this code by running python hello.py. Notice how the + sign concatenates \"hello, \" and answer.\n\nSimilarly, you could implement the above code as:\n\n# get_string and print, with format strings\n\nfrom cs50 import get_string\n\nanswer = get_string(\"What's your name? \")\nprint(f\"hello, {answer}\")\nNotice how the curly braces allow for the print function to interpolate the answer such that answer appears within. The f is required to include the answer properly formatting.\n\nVariables\nVariable declaration is simplified too. In C, you might have int counter = 0;. In Python, this same line would read counter = 0. You need not declare the type of the variable.\nPython favors counter += 1 to increment by one, losing the ability found in C to type counter++.\nTypes\nData types in Python do not need to be explicitly declared. For example, you saw how answer above is a string, but we did not have to tell the interpreter this was the case: It knew on its own.\nIn Python, commonly used types include:\n\n  bool\n  float\n  int\n  str\nNotice that long and double are missing. Python will handle what data type should be used for larger and smaller numbers.\n\nSome other data types in Python include:\n\n  range\n  list\n  tuple\n  dict\n  set\nEach of these data types can be implemented in C, but in Python they can be implemented more simply.\nCalculator\nYou might recall calculator.c from earlier in the course:\n\n// Addition with int\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // Prompt user for x\n    int x = get_int(\"x: \");\n\n    // Prompt user for y\n    int y = get_int(\"y: \");\n\n    // Perform addition\n    printf(\"%i\\n\", x + y);\n}\nWe can implement a simple calculator just as we did within C. Type code calculator.py into the terminal window and write code as follows:\n\n# Addition with int [using get_int]\n\nfrom cs50 import get_int\n\n# Prompt user for x\nx = get_int(\"x: \")\n\n# Prompt user for y\ny = get_int(\"y: \")\n\n# Perform addition\nprint(x + y)\nNotice how the CS50 library is imported. Then, x and y are gathered from the user. Finally, the result is printed. Notice that the main function that would have been seen in a C program is gone entirely! While one could utilize a main function, it is not required.\n\nIt\u2019s possible for one to remove the training wheels of the CS50 library. Modify your code as follows:\n\n# Addition with int [using input]\n\n# Prompt user for x\nx = input(\"x: \")\n\n# Prompt user for y\ny = input(\"y: \")\n\n# Perform addition\nprint(x + y)\nNotice how executing the above code results in strange program behavior. Why might this be so?\n\nYou may have guessed that the interpreter understood x and y to be strings. You can fix your code by employing the int function as follows:\n\n# Addition with int [using input]\n\n# Prompt user for x\nx = int(input(\"x: \"))\n\n# Prompt user for y\ny = int(input(\"y: \"))\n\n# Perform addition\nprint(x + y)\nNotice how the input for x and y is passed to the int function which converts it to an integer. Without converting x and y to be integers, the characters will concatenate.\n\nConditionals\nIn C, you might remember a program like this:\n\n// Conditionals, Boolean expressions, relational operators\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // Prompt user for integers\n    int x = get_int(\"What's x? \");\n    int y = get_int(\"What's y? \");\n\n    // Compare integers\n    if (x < y)\n    {\n        printf(\"x is less than y\\n\");\n    }\n    else if (x > y)\n    {\n        printf(\"x is greater than y\\n\");\n    }\n    else\n    {\n        printf(\"x is equal to y\\n\");\n    }\n}\nIn Python, it would appear as follows:\n\n# Conditionals, Boolean expressions, relational operators\n\nfrom cs50 import get_int\n\n# Prompt user for integers\nx = get_int(\"What's x? \")\ny = get_int(\"What's y? \")\n\n# Compare integers\nif x < y:\n    print(\"x is less than y\")\nelif x > y:\n    print(\"x is greater than y\")\nelse:\n    print(\"x is equal to y\")\nNotice that there are no more curly braces. Instead, indentations are utilized. Second, a colon is utilized in the if statement. Further, elif replaces else if. Parentheses are also no longer required in the if and elif statements.\n\nIn C, we faced challenges when we wanted to compare two values. Consider the following code:\n\n// Conditionals, Boolean expressions, relational operators\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // Prompt user for integers\n    int x = get_int(\"What's x? \");\n    int y = get_int(\"What's y? \");\n\n    // Compare integers\n    if (x < y)\n    {\n        printf(\"x is less than y\\n\");\n    }\n    else if (x > y)\n    {\n        printf(\"x is greater than y\\n\");\n    }\n    else\n    {\n        printf(\"x is equal to y\\n\");\n    }\n}\nIn Python, we can execute the above as follows:\n\n# Conditionals, Boolean expressions, relational operators\n\nfrom cs50 import get_int\n\n# Prompt user for integers\nx = get_int(\"What's x? \")\ny = get_int(\"What's y? \")\n\n# Compare integers\nif x < y:\n    print(\"x is less than y\")\nelif x > y:\n    print(\"x is greater than y\")\nelse:\n    print(\"x is equal to y\")\nNotice that the CS50 library is imported. Further, minor changes exist in the if statement.\n\nFurther looking at comparisons, consider the following code in C:\n\n// Logical operators\n\n#include <cs50.h>\n#include <stdio.h>\n\nint main(void)\n{\n    // Prompt user to agree\n    char c = get_char(\"Do you agree? \");\n\n    // Check whether agreed\n    if (c == 'Y' || c == 'y')\n    {\n        printf(\"Agreed.\\n\");\n    }\n    else if (c == 'N' || c == 'n')\n    {\n        printf(\"Not agreed.\\n\");\n    }\n}\nThe above can be implemented as follows:\n\n# Logical operators\n\nfrom cs50 import get_string\n\n# Prompt user to agree\ns = get_string(\"Do you agree? \")\n\n# Check whether agreed\nif s == \"Y\" or s == \"y\":\n    print(\"Agreed.\")\nelif s == \"N\" or s == \"n\":\n    print(\"Not agreed.\")\nNotice that the two vertical bars utilized in C is replaced with or. Indeed, people often enjoy Python because it is more readable by humans. Also, notice that char does not exist in Python. Instead, strs are utilized.\n\nAnother approach to this same code could be as follows using lists:\n\n# Logical operators, using lists\n\nfrom cs50 import get_string\n\n# Prompt user to agree\ns = get_string(\"Do you agree? \")\n\n# Check whether agreed\nif s in [\"y\", \"yes\"]:\n    print(\"Agreed.\")\nelif s in [\"n\", \"no\"]:\n    print(\"Not agreed.\")\nNotice how we are able to express multiple keywords like y and yes in a list.\n\nObject-Oriented Programming\nUp until this point, our programs in this course have been linear: sequential.\nIt\u2019s possible to have certain types of values not only have properties or attributes inside of them but have functions as well. In Python, these values are known as objects\nIn C, we could create a struct where you could associate multiple variables inside a single self-created data type. In Python, we can do this and also include functions in a self-created data type. When a function belongs to a specific object, it is known as a method.\nFor example, strs in Python have a built-in methods. Therefore, you could modify your code as follows:\n\n# Logical operators, using lists\n\nfrom cs50 import get_string\n\n# Prompt user to agree\ns = get_string(\"Do you agree? \").lower()\n\n# Check whether agreed\nif s.lower() in [\"y\", \"yes\"]:\n    print(\"Agreed.\")\nelif s.lower() in [\"n\", \"no\"]:\n    print(\"Not agreed.\")\nNotice how the old value of s is overwritten with the result of s.lower(), a built-in method of strs.\n\nIn this class, we will only scratch the surface of Python. Therefore, the Python documentation will be of particular importance as you continue.\nYou can learn more about string methods in the Python documentation\nLoops\nLoops in Python are very similar to C. You may recall the following code in C:\n\n// Demonstrates while loop\n\n#include <stdio.h>\n\nint main(void)\n{\n    int i = 0;\n    while (i < 3)\n    {\n        printf(\"meow\\n\");\n        i++;\n    }\n}\nIn Python, this code appears as:\n\n# Demonstrates while loop\n\ni = 0\nwhile i < 3:\n    print(\"meow\")\n    i += 1\nfor loops can be implemented in Python as follows:\n\n# Better design\n\nfor i in range(3):\n    print(\"meow\")\nNotice that i is never explicitly used. However, Python will increment the value of i.\n\nSimilarly, one could express the above code as:\n\n# Abstraction with parameterization\n\ndef main():\n    meow(3)\n\n\n# Meow some number of times\ndef meow(n):\n    for i in range(n):\n        print(\"meow\")\n\n\nmain()\nNotice that a function is utilized to abstract away the meowing.\n\nFinally, a while loop could be implemented as follows:\n\n# Demonstrates while loop\n\ni = 0\nwhile i < 3:\n    print(\"meow\")\n    i += 1\nTo further our understanding of loops and iteration in Python, let\u2019s create a new file called uppercase.py as follows:\n\n# Uppercases string one character at a time\n\nbefore = input(\"Before: \")\nprint(\"After:  \", end=\"\")\nfor c in before:\n    print(c.upper(), end=\"\")\nprint()\nNotice how end= is used to pass a parameter to the print function that continues the line without a line ending. This code passes one string at a time.\n\nReading the documentation, we discover that Python has methods that can be implemented upon the entire string as follows:\n\n# Uppercases string all at once\n\nbefore = input(\"Before: \")\nafter = before.upper()\nprint(f\"After:  {after}\")\nNotice how .upper is applied to the entire string.\n\nAbstraction\nAs we hinted at earlier today, you can further improve upon our code using functions and abstracting away various code into functions. Modify your earlier-created meow.py code as follows:\n\n# Abstraction\n\ndef main():\n    for i in range(3):\n        meow()\n\n# Meow once\ndef meow():\n    print(\"meow\")\n\n\nmain()\nNotice that the meow function abstracts away the print statement. Further, notice that the main function appears at the top of the file. At the bottom of the file, the main function is called. By convention, it\u2019s expected that you create a main function in Python.\n\nIndeed, we can pass variables between our functions as follows:\n\n# Abstraction with parameterization\n\ndef main():\n    meow(3)\n\n\n# Meow some number of times\ndef meow(n):\n    for i in range(n):\n        print(\"meow\")\n\n\nmain()\nNotice how meow now takes a variable n. In the main function, you can call meow and pass a value like 3 to it. Then, meow utilizes the value of n in the for loop.\n\nReading the above code, notice how you, as a C programmer, are able to quite easily make sense of the above code. While some conventions are different, the building blocks you previously learned are very apparent in this new programming language.\n\nTruncation and Floating Point Imprecision\nRecall that in C, we experienced truncation where one integer being divided by another could result in an inprecise result.\nYou can see how Python handles such division as follows by modifying your code for calculator.py:\n\n# Division with integers, demonstration lack of truncation\n\n# Prompt user for x\nx = int(input(\"x: \"))\n\n# Prompt user for y\ny = int(input(\"y: \"))\n\n# Divide x by y\nz = x / y\nprint(z)\nNotice that executing this code results in a value, but that if you were to see more digits after .333333 you\u2019d see that we are faced with floating-point imprecision. Truncation does not occur.\n\nWe can reveal this imprecision by modifying our codes slightly:\n\n# Floating-point imprecision\n\n# Prompt user for x\nx = int(input(\"x: \"))\n\n# Prompt user for y\ny = int(input(\"y: \"))\n\n# Divide x by y\nz = x / y\nprint(f\"{z:.50f}\")\nNotice that this code reveals the imprecision. Python still faces this issue, just as C does.\n\nExceptions\nLet\u2019s explore more about exceptions that can occur when we run Python code.\nModify calculator.py as follows:\n\n# Implements get_int\n\ndef get_int(prompt):\n    return int(input(prompt))\n\n\ndef main():\n\n    # Prompt user for x\n    x = get_int(\"x: \")\n\n    # Prompt user for y\n    y = get_int(\"y: \")\n\n    # Perform addition\n    print(x + y)\n\n\nmain()\nNotice that inputting the wrong data could result in an error.\n\nWe can try to handle and catch potential exceptions by modifying our code as follows:\n\n# Implements get_int with a loop\n\ndef get_int(prompt):\n    while True:\n        try:\n            return int(input(prompt))\n        except ValueError:\n            print(\"Not an integer\")\n\n\ndef main():\n\n    # Prompt user for x\n    x = get_int(\"x: \")\n\n    # Prompt user for y\n    y = get_int(\"y: \")\n\n    # Perform addition\n    print(x + y)\n\n\nmain()\nNotice that the above code repeatedly tries to get the correct type of data, providing additional prompts when needed.\n\nMario\nRecall a few weeks ago our challenge of building three blocks on top of one another, like in Mario.\n\nthree vertical blocks\n\nIn Python, we can implement something akin to this as follows:\n\n# Prints a column of 3 bricks with a loop\n\nfor i in range(3):\n    print(\"#\")\nIn C, we had the advantage of a do-while loop. However, in Python it is convention to utilize a while loop, as Python does not have a do while loop. You can write code as follows in a file called mario.py:\n\n# Prints a column of n bricks with a loop\n\nfrom cs50 import get_int\n\nwhile True:\n    n = get_int(\"Height: \")\n    if n > 0:\n        break\n\nfor i in range(n):\n    print(\"#\")\nNotice how the while loop is used to obtain the height. Once a height greater than zero is inputted, the loop breaks.\n\nConsider the following image:\n\nfour horizontal question blocks\n\nIn Python, we could implement by modifying your code as follows:\n\n# Prints a row of 4 question marks with a loop\n\nfor i in range(4):\n    print(\"?\", end=\"\")\nprint()\nNotice that you can override the behavior of the print function to stay on the same line as the previous print.\n\nSimilar in spirit to previous iterations, we can further simplify this program:\n\n# Prints a row of 4 question marks without a loop\n\nprint(\"?\" * 4)\nNotice that we can utilize * to multiply the print statement to repeat 4 times.\n\nWhat about a large block of bricks?\n\nthree by three block of mario blocks\n\nTo implement the above, you can modify your code as follows:\n\n# Prints a 3-by-3 grid of bricks with loops\n\nfor i in range(3):\n    for j in range(3):\n        print(\"#\", end=\"\")\n    print()\nNotice how one for loop exists inside another. The print statement adds a new line at the end of each row of bricks.\n\nYou can learn more about the print function in the Python documentation\n\nLists\nlists are a data structure within Python.\nlists have built in methods or functions within them.\nFor example, consider the following code:\n\n# Averages three numbers using a list\n\n# Scores\nscores = [72, 73, 33]\n\n# Print average\naverage = sum(scores) / len(scores)\nprint(f\"Average: {average}\")\nNotice that you can use the built-in sum method to calculate the average.\n\nYou can even utilize the following syntax to get values from the user:\n\n# Averages three numbers using a list and a loop\n\nfrom cs50 import get_int\n\n# Get scores\nscores = []\nfor i in range(3):\n    score = get_int(\"Score: \")\n    scores.append(score)\n\n# Print average\naverage = sum(scores) / len(scores)\nprint(f\"Average: {average}\")\nNotice that this code utilizes the built-in append method for lists.\n\nYou can learn more about lists in the Python documentation\nYou can also learn more about len in the Python documentation\nSearching and Dictionaries\nWe can also search within a data structure.\nConsider a program called phonebook.py as follows:\n\n# Implements linear search for names using loop\n\n# A list of names\nnames = [\"Carter\", \"David\", \"John\"]\n\n# Ask for name\nname = input(\"Name: \")\n\n# Search for name\nfor n in names:\n    if name == n:\n        print(\"Found\")\n        break\nelse:\n    print(\"Not found\")\nNotice how this implements linear search for each name.\n\nHowever, we don\u2019t need to iterate through a list. In Python, we can execute linear search as follows:\n\n# Implements linear search for names using `in`\n\n# A list of names\nnames = [\"Carter\", \"David\", \"John\"]\n\n# Ask for name\nname = input(\"Name: \")\n\n# Search for name\nif name in names:\n    print(\"Found\")\nelse:\n    print(\"Not found\")\nNotice how in is used to implement linear search.\n\nStill, this code could be improved.\nRecall that a dictionary or dict is a collection of key and value pairs.\nYou can implement a dictionary in Python as follows:\n\n# Implements a phone book as a list of dictionaries, without a variable\n\nfrom cs50 import get_string\n\npeople = [\n    {\"name\": \"Carter\", \"number\": \"+1-617-495-1000\"},\n    {\"name\": \"David\", \"number\": \"+1-617-495-1000\"},\n    {\"name\": \"John\", \"number\": \"+1-949-468-2750\"},\n]\n\n# Search for name\nname = get_string(\"Name: \")\nfor person in people:\n    if person[\"name\"] == name:\n        print(f\"Found {person['number']}\")\n        break\nelse:\n    print(\"Not found\")\nNotice that the dictionary is implemented having both name and number for each entry.\n\nEven better, strictly speaking, we don\u2019t need both a name and a number. We can simplify this code as follows:\n\n# Implements a phone book using a dictionary\n\nfrom cs50 import get_string\n\npeople = {\n    \"Carter\": \"+1-617-495-1000\",\n    \"David\": \"+1-617-495-1000\",\n    \"John\": \"+1-949-468-2750\",\n}\n\n# Search for name\nname = get_string(\"Name: \")\nif name in people:\n    print(f\"Number: {people[name]}\")\nelse:\n    print(\"Not found\")\nNotice that the dictionary is implemented using curly braces. Then, the statement if name in people searches to see if the name is in the people dictionary. Further, notice how, in the print statement, we can index into the people dictionary using the value of name. Very useful!\n\nPython has done their best to get to constant time using their built-in searches.\nYou can learn more about dictionaries in the Python documentation\nCommand-Line Arguments\nAs with C, you can also utilize command-line arguments. Consider the following code:\n\n# Prints a command-line argument\n\nfrom sys import argv\n\nif len(argv) == 2:\n    print(f\"hello, {argv[1]}\")\nelse:\n    print(\"hello, world\")\nNotice that argv[1] is printed using a formatted string, noted by the f present in the print statement.\n\nYou can print all the arguments in argv as follows:\n\n# Printing command-line arguments, indexing into argv\n\nfrom sys import argv\n\nfor i in range(len(argv)):\n    print(argv[i])\nNotice that the above will not present the word python if executed, and the first argument will be the name of the file you are running. You can think of the word python as being analogous to ./ when we were running programs in C.\n\nYou can slice pieces of lists away. Consider the following code:\n\n# Printing command-line arguments\n\nfrom sys import argv\n\nfor arg in argv:\n    print(arg)\nNotice that executing this code will result in the name of the file you are running being sliced away.\n\nYou can learn more about the sys library in the Python documentation\n\nExit Status\nThe sys library also has built-in methods. We can use sys.exit(i) to exit the program with a specific exit code:\n\n# Exits with explicit value, importing sys\n\nimport sys\n\nif len(sys.argv) != 2:\n    print(\"Missing command-line argument\")\n    sys.exit(1)\n\nprint(f\"hello, {sys.argv[1]}\")\nsys.exit(0)\nNotice that dot-notation is used to utilize the built-in functions of sys.\n\nThird-Party Libraries\nOne of the advantages of Python is its massive user-base and similarly large number of third-party libraries.\nFor example, David demoed the use of cowsay and qrcode libraries.\nSumming Up\nIn this lesson, you learned how the building blocks of programming from prior lessons can be implemented within Python. Further, you learned about how Python allowed for more simplified code. Also, you learned how to utilize various Python libraries. In the end, you learned that your skills as a programmer are not limited to a single programming language. Already, you are seeing how you are discovering a new way of learning through this course that could serve you in any programming language \u2013 and, perhaps, in nearly any avenue of learning! Specifically, we discussed\u2026\n\nPython\nVariables\nConditionals\nLoops\nTypes\nObject-Oriented programming\nTruncation and floating point imprecision\nExceptions\nDictionaries\nCommand-line arguments\nThird-Party libraries\nSee you next time!"
        },
        {
            "lecture": 7,
            "content": "Lecture 7\nWelcome!\nFlat-File Database\nRelational Databases\nShows\nJOINs\nIndexes\nUsing SQL in Python\nRace Conditions\nSQL Injection Attacks\nSumming Up\nWelcome!\nIn previous weeks, we introduced you to Python, a high-level programming language that utilized the same building blocks we learned in C. However, we introduced this new language not for the purpose of learning \u201cjust another language.\u201d Instead, we do so because some tools are better for some jobs and not so great for others!\nThis week, we will be continuing more syntax related to Python.\nFurther, we will be integrating this knowledge with data.\nFinally, we will be discussing SQL or Structured Query Language.\nOverall, one of the goals of this course is to learn to program generally \u2013 not simply how to program in the languages described in this course.\nFlat-File Database\nAs you have likely seen before, data can often be described in patterns of columns and rows.\nSpreadsheets like those created in Microsoft Excel and Google Sheets can be outputted to a csv or comma-separated values file.\nIf you look at a csv file, you\u2019ll notice that the file is flat in that all of our data is stored in a single table represented by a text file. We call this form of data a flat-file database.\nPython comes with native support for csv files.\nFirst, download favorites.csv and upload it to your file explorer inside cs50.dev. Second, in your terminal window, type code favorites.py and write code as follows:\n\n# Prints all favorites in CSV using csv.reader\n\nimport csv\n\n# Open CSV file\nwith open(\"favorites.csv\", \"r\") as file:\n\n    # Create reader\n    reader = csv.reader(file)\n\n    # Skip header row\n    next(reader)\n\n    # Iterate over CSV file, printing each favorite\n    for row in reader:\n        print(row[1])\nNotice that the csv library is imported. Further, we created a reader that will hold the result of csv.reader(file). The csv.reader function reads each row from the file, and in our code we store the results in reader. print(row[1]), therefore, will print the language from the favorites.csv file.\n\nYou can improve your code as follows:\n\n# Stores favorite in a variable\n\nimport csv\n\n# Open CSV file\nwith open(\"favorites.csv\", \"r\") as file:\n\n    # Create reader\n    reader = csv.reader(file)\n\n    # Skip header row\n    next(reader)\n\n    # Iterate over CSV file, printing each favorite\n    for row in reader:\n        favorite = row[1]\n        print(favorite)\nNotice that favorite is stored and then printed. Also notice that we use the next function to skip to the next line of our reader.\n\nOne of the disadvantages of the above approach is that we are trusting that row[1] is always the favorite. However, what would happen if the columns have been moved around?\nWe can fix this potential issue. Python also allows you to index by the keys of a list. Modify your code as follows:\n\n# Prints all favorites in CSV using csv.DictReader\n\nimport csv\n\n# Open CSV file\nwith open(\"favorites.csv\", \"r\") as file:\n\n    # Create DictReader\n    reader = csv.DictReader(file)\n\n    # Iterate over CSV file, printing each favorite\n    for row in reader:\n        favorite = row[\"language\"]\n        print(favorite)\nNotice that this example directly utilizes the language key in the print statement.\n\nThis could be further simplified to:\n\n# Prints all favorites in CSV using csv.DictReader\n\nimport csv\n\n# Open CSV file\nwith open(\"favorites.csv\", \"r\") as file:\n\n    # Create DictReader\n    reader = csv.DictReader(file)\n\n    # Iterate over CSV file, printing each favorite\n    for row in reader:\n        print(row[\"language\"])\nTo count the number of favorite languages expressed in the csv file, we can do the following:\n\n# Counts favorites using variables\n\nimport csv\n\n# Open CSV file\nwith open(\"favorites.csv\", \"r\") as file:\n\n    # Create DictReader\n    reader = csv.DictReader(file)\n\n    # Counts\n    scratch, c, python = 0, 0, 0\n\n    # Iterate over CSV file, counting favorites\n    for row in reader:\n        favorite = row[\"language\"]\n        if favorite == \"Scratch\":\n            scratch += 1\n        elif favorite == \"C\":\n            c += 1\n        elif favorite == \"Python\":\n            python += 1\n\n# Print counts\nprint(f\"Scratch: {scratch}\")\nprint(f\"C: {c}\")\nprint(f\"Python: {python}\")\nNotice that each language is counted using if statements. Further notice the double equal == signs in those if statements.\n\nPython allows us to use a dictionary to count the counts of each language. Consider the following improvement upon our code:\n\n# Counts favorites using dictionary\n\nimport csv\n\n# Open CSV file\nwith open(\"favorites.csv\", \"r\") as file:\n\n    # Create DictReader\n    reader = csv.DictReader(file)\n\n    # Counts\n    counts = {}\n\n    # Iterate over CSV file, counting favorites\n    for row in reader:\n        favorite = row[\"language\"]\n        if favorite in counts:\n            counts[favorite] += 1\n        else:\n            counts[favorite] = 1\n\n# Print counts\nfor favorite in counts:\n    print(f\"{favorite}: {counts[favorite]}\")\nNotice that the value in counts with the key favorite is incremented when it exists already. If it does not exist, we define counts[favorite] and set it to 1. Further, the formatted string has been improved to present the counts[favorite].\n\nPython also allows sorting counts. Improve your code as follows:\n\n# Sorts favorites by key\n\nimport csv\n\n# Open CSV file\nwith open(\"favorites.csv\", \"r\") as file:\n\n    # Create DictReader\n    reader = csv.DictReader(file)\n\n    # Counts\n    counts = {}\n\n    # Iterate over CSV file, counting favorites\n    for row in reader:\n        favorite = row[\"language\"]\n        if favorite in counts:\n            counts[favorite] += 1\n        else:\n            counts[favorite] = 1\n\n# Print counts\nfor favorite in sorted(counts):\n    print(f\"{favorite}: {counts[favorite]}\")\nNotice the sorted(counts) at the bottom of the code.\n\nIf you look at the parameters for the sorted function in the Python documentation, you will find it has many built-in parameters. You can leverage some of these built-in parameters as follows:\n\n# Sorts favorites by value using .get\n\nimport csv\n\n# Open CSV file\nwith open(\"favorites.csv\", \"r\") as file:\n\n    # Create DictReader\n    reader = csv.DictReader(file)\n\n    # Counts\n    counts = {}\n\n    # Iterate over CSV file, counting favorites\n    for row in reader:\n        favorite = row[\"language\"]\n        if favorite in counts:\n            counts[favorite] += 1\n        else:\n            counts[favorite] = 1\n\n# Print counts\nfor favorite in sorted(counts, key=counts.get, reverse=True):\n    print(f\"{favorite}: {counts[favorite]}\")\nNotice the arguments passed to sorted. The key argument allows you to tell Python the method you wish to use to sort items. In this case counts.get is used to sort by the values. reverse=True tells sorted to sort from largest to smallest.\n\nPython has numerous libraries that we can utilize in our code. One of these libraries is collections, from which we can import Counter. Counter will allow you to access the counts of each language without the headaches of all the if statements seen in our previous code. You can implement as follows:\n\n# Sorts favorites by value using .get\n\nimport csv\n\nfrom collections import Counter\n\n# Open CSV file\nwith open(\"favorites.csv\", \"r\") as file:\n\n    # Create DictReader\n    reader = csv.DictReader(file)\n\n    # Counts\n    counts = Counter()\n\n    # Iterate over CSV file, counting favorites\n    for row in reader:\n        favorite = row[\"language\"]\n        counts[favorite] += 1\n\n# Print counts\nfor favorite, count in counts.most_common():\n    print(f\"{favorite}: {count}\")\nNotice how counts = Counter() enables the use of this imported Counter class from collections.\n\nWe can change the column we are examining, focusing on our favorite problem instead:\n\n# Favorite problem instead of favorite language\n\nimport csv\n\nfrom collections import Counter\n\n# Open CSV file\nwith open(\"favorites.csv\", \"r\") as file:\n\n    # Create DictReader\n    reader = csv.DictReader(file)\n\n    # Counts\n    counts = Counter()\n\n    # Iterate over CSV file, counting favorites\n    for row in reader:\n        favorite = row[\"problem\"]\n        counts[favorite] += 1\n\n# Print counts\nfor favorite, count in counts.most_common():\n    print(f\"{favorite}: {count}\")\nNotice that problem replaced language.\n\nWe can also get the count of the popularity of a specific problem in the course:\n\n# Gets a specific count\n\nimport csv\n\nfrom collections import Counter\n\n# Open CSV file\nwith open(\"favorites.csv\", \"r\") as file:\n\n    # Create DictReader\n    reader = csv.DictReader(file)\n\n    # Counts\n    counts = Counter()\n\n    # Iterate over CSV file, counting favorites\n    for row in reader:\n        favorite = row[\"problem\"]\n        counts[favorite] += 1\n\n# Print count\nfavorite = input(\"Favorite: \")\nprint(f\"{favorite}: {counts[favorite]}\")\nNotice how compact our code is compared to our experience in C.\n\nRelational Databases\nGoogle, Twitter, and Meta all use relational databases to store their information at scale.\nRelational databases store data in rows and columns in structures called tables.\nSQL allows for four types of commands:\n\n  Create\n  Read\n  Update\n  Delete\nThese four operations are affectionately called CRUD.\nWe can create a SQL database at the terminal by typing sqlite3 favorites.db. Upon being prompted, we will agree that we want to create favorites.db by pressing y.\nYou will notice a different prompt as we are now inside a program called sqlite3.\nWe can put sqlite3 into csv mode by typing .mode csv. Then, we can import our data from our csv file by typing .import favorites.csv favorites. It seems that nothing has happened!\nWe can type .schema to see the structure of the database.\nYou can read items from a table using the syntax SELECT columns FROM table.\nFor example, you can type SELECT * FROM favorites; which will iterate every row in favorites.\nYou can get a subset of the data using the command SELECT language FROM favorites;.\nSQL supports many commands to access data, including:\n\n  AVG\n  COUNT\n  DISTINCT\n  LOWER\n  MAX\n  MIN\n  UPPER\nFor example, you can type SELECT COUNT(language) FROM favorites;. Further, you can type SELECT DISTINCT(language) FROM favorites; to get a list of the individual languages within the database. You could even type SELECT COUNT(DISTINCT(language)) FROM favorites; to get a count of those.\nSQL offers additional commands we can utilize in our queries:\n\n  WHERE       -- adding a Boolean expression to filter our data\n  LIKE        -- filtering responses more loosely\n  ORDER BY    -- ordering responses\n  LIMIT       -- limiting the number of responses\n  GROUP BY    -- grouping responses together\nNotice that we use -- to write a comment in SQL.\n\nFor example, we can execute SELECT COUNT(*) FROM favorites WHERE language = 'C';. A count is presented.\nFurther, we could type SELECT COUNT(*) FROM favorites WHERE language = 'C' AND problem = 'Hello, World;. Notice how the AND is utilized to narrow our results.\nSimilarly, we could execute SELECT language, COUNT(*) FROM favorites GROUP BY language;. This would offer a temporary table that would show the language and count.\nWe could improve this by typing SELECT language, COUNT(*) FROM favorites GROUP BY language ORDER BY COUNT(*);. This will order the resulting table by the count.\nWe can also INSERT into a SQL database utilizing the form INSERT INTO table (column...) VALUES(value, ...);.\nWe can execute INSERT INTO favorites (language, problem) VALUES ('SQL', 'Fiftyville');.\nDELETE allows you to delete parts of your data. For example, you could DELETE FROM favorites WHERE Timestamp IS NULL;.\nWe can also utilize the UPDATE command to update your data.\nFor example, you can execute UPDATE favorites SET language = 'SQL', problem = 'Fiftyville';. This will result in overwriting all previous statements where C was the favorite programming language.\nNotice that these queries have immense power. Accordingly, in the real-world setting, you should consider who has permissions to execute certain commands.\nShows\nWe can imagine a database that we might want to create to catalog various TV shows. We could create a spreadsheet with columns like title, star, star, star, star, and more stars. A problem with this approach is this approach has a lot of wasted space. Some shows may have one star. Others may have dozens.\nWe could separate our database into multiple sheets. We could have a shows sheet and a people sheet. On the people sheet, each person could have a unique id. On the shows sheet, each show could have a unique id too. On a third sheet called stars we could relate how each show has people for each show by having a show_id and person_id. While this is an improvement, this is not an ideal database.\nIMDb offers a database of people, shows, writers, stars, genres, and ratings. Each of these tables is related to one another as follows:\n\nsix boxes that represent various sql tables arrows are drawn to each showing their many relationships with one another\n\nAfter downloading shows.db, you can execute sqlite3 shows.db in your terminal window.\nLet\u2019s zero in on the relationship between two tables within the database called shows and ratings. The relationship between these two tables can be illustrated as follows:\n\ntwo boxes one called shows and the other called ratings\n\nTo illustrate the relationship between these tables, we could execute the following command: SELECT * FROM ratings LIMIT 10;. Examining the output, we could execute SELECT * FROM shows LIMIT 10;.\nTo understand the database, upon executing .schema you will find not only each of the tables but the individual fields inside each of these fields.\nAs you can see, shows has an id field. The genres table has a show_id field which has data that is common between it and the shows table.\nFurther, show_id exists in all of the tables. In the shows table, it is simply called id. This common field between all the fields is called a key. Primary keys are used to identify a unique record in a table. Foreign keys are used to build relationships between tables by pointing to the primary key in another table.\nBy storing data in a relational database, as above, data can be more efficiently stored.\nIn sqlite, we have five datatypes, including:\n\n  BLOB       -- binary large objects that are groups of ones and zeros\n  INTEGER    -- an integer\n  NUMERIC    -- for numbers that are formatted specially like dates\n  REAL       -- like a float\n  TEXT       -- for strings and the like\nAdditionally, columns can be set to add special constraints:\n\n  NOT NULL\n  UNIQUE\nWe could execute SELECT * FROM stars LIMIT 10;. show_id is a foreign key in this final query because show_id corresponds to the unique id field in shows. person_id corresponds to the unique id field in the people column.\nWe can further play with this data to understand these relationships. Execute SELECT * FROM ratings;. There are a lot of ratings!\nWe can further limit this data down by executing SELECT show_id FROM ratings WHERE rating >= 6.0 LIMIT 10;. From this query, you can see that there are 10 shows presented. However, we don\u2019t know what show each show_id represents.\nYou can discover what shows these are by executing SELECT * FROM shows WHERE id = 626124;\nWe can further our query to be more efficient by executing:\n\nSELECT title\nFROM shows\nWHERE id IN (\n    SELECT show_id\n    FROM ratings\n    WHERE rating >= 6.0\n    LIMIT 10\n)\nNotice that this query nests together two queries. An inner query is used by an outer query.\n\nJOINs\nWe are pulling data from shows and ratings.\nHow could we combine tables temporarily? Tables could be joined together using the JOIN command.\nExecute the following command:\n\nSELECT * FROM shows\n  JOIN ratings on shows.id = ratings.show_id\n  WHERE rating >= 6.0\n  LIMIT 10;\nNotice this results in a wider table than we have previously seen.\n\nWhere the previous queries have illustrated the one-to-one relationship between these keys, let\u2019s examine some one-to-many relationships. Focusing on the genres table, execute the following:\n\nSELECT * FROM genres\nLIMIT 10;\nNotice how this provides us a sense of the raw data. You might notice that one shows have three values. This is a one-to-many relationship.\n\nWe can learn more about the genres table by typing .schema genres.\nExecute the following command to learn more about the various comedies in the database:\n\nSELECT title FROM shows\nWHERE id IN (\n  SELECT show_id FROM genres\n  WHERE genre = 'Comedy'\n  LIMIT 10\n);\nNotice how this produces a list of comedies, including Catweazle.\n\nTo learn more about Catweazle, by joining various tables through a join:\n\nSELECT * FROM shows\nJOIN genres\nON shows.id = genres.show_id\nWHERE id = 63881;\nNotice that this results in a temporary table. It is fine to have duplicate table.\n\nA final relationship is a many-to-many relationship.\nWe can learn more about the show The Office by executing the following command:\n\nSELECT person_id FROM stars\nWHERE show_id = (\n  SELECT id FROM shows\n  WHERE title = 'The Office' AND year = 2005\n);\nNotice that this results in a table that includes the person_ids of various stars.\n\nI could learn more about this group of actors by executing the following:\n\nSELECT name FROM people\nWHERE id IN (\n    SELECT person_id FROM stars\n    WHERE show_id = (\n      SELECT id FROM shows\n      WHERE title = 'The Office' AND year = 2005\n    )\n);\nThis results in a top-billed stars.\n\nWe can further understand this data by executing:\n\nSELECT title from shows\nWHERE id IN (\n  SELECT show_id FROM stars\n  WHERE person_id = (\n    SELECT id FROM people\n    WHERE name = 'Steve Carell'\n  )\n);\nThis results in a list of titles of shows wherein Steve Carell stared.\n\nThe wildcard % operator can be used to find all people whose names start with Steve C one could employ the syntax SELECT * FROM people WHERE name LIKE 'Steve C%';.\nIndexes\nWhile relational databases have the ability to be more fast and more robust than utilizing a CSV file, data can be optimized within a table using indexes.\nIndexes can be utilized to speed up our queries.\nWe can track the speed of our queries by executing .timer on in sqlite3.\nTo understand how indexes can speed up our queries, run the following: SELECT * FROM shows WHERE title = 'The Office'; Notice the time that displays after the query executes.\nThen, we can create an index with the syntax CREATE INDEX title_index on shows (title);. This tells sqlite3 to create an index and perform some special under-the-hood optimization relating to this column title.\nThis will create a data structure called a B Tree, a data structure that looks similar to a binary tree. However, unlike a binary tree, there can be more than two child notes.\n\none node at the top from which come four children and below that there are three children coming from one of the nodes and two from another two from another and three from another\n\nRunning the query SELECT * FROM shows WHERE title = 'The Office';, you will notice that the query runs much more quickly!\nUnfortunately, indexing all columns would result in utilizing more storage space. Therefore, there is a tradeoff for enhanced speed.\nUsing SQL in Python\nTo assist in working with SQL in this course, the CS50 Library can be utilized as follows in your code:\n\nfrom cs50 import SQL\nSimilar to previous uses of the CS50 Library, this library will assist with the complicated steps of utilizing SQL within your Python code.\nYou can read more about the CS50 Library\u2019s SQL functionality in the documentation.\nRecall where we last left off in favorites.py. Your code should appear as follows:\n\n# Gets a specific count\n\nimport csv\n\nfrom collections import Counter\n\n# Open CSV file\nwith open(\"favorites.csv\", \"r\") as file:\n\n    # Create DictReader\n    reader = csv.DictReader(file)\n\n    # Counts\n    counts = Counter()\n\n    # Iterate over CSV file, counting favorites\n    for row in reader:\n        favorite = row[\"problem\"]\n        counts[favorite] += 1\n\n# Print count\nfavorite = input(\"Favorite: \")\nprint(f\"{favorite}: {counts[favorite]}\")\nNotice how this code is exactly as we left it prior.\n\nModify your code as follows:\n\n# Searches database popularity of a problem\n\nimport csv\n\nfrom cs50 import SQL\n\n# Open database\ndb = SQL(\"sqlite:///favorites.db\")\n\n# Prompt user for favorite\nfavorite = input(\"Favorite: \")\n\n# Search for title\nrows = db.execute(\"SELECT COUNT(*) AS n FROM favorites WHERE problem LIKE ?\", favorite)\n\n# Get first (and only) row\nrow = rows[0]\n\n# Print popularity\nprint(row[\"n\"])\nNotice that db = SQL(\"sqlite:///favorites.db\") provide Python the location of the database file. Then, the line that begins with rows executes SQL commands utilizing db.execute. Indeed, this command passes the syntax within the quotation marks to the db.execute function. We can issue any SQL command using this syntax. Further, notice that rows is returned as a list of dictionaries. In this case, there is only one result, one row, returned to the rows list as a dictionary.\n\nRace Conditions\nUtilization of SQL can sometimes result in some problems.\nYou can imagine a case where multiple users could be accessing the same database and executing commands at the same time.\nThis could result in glitches where code is interrupted by other people\u2019s actions. This could result in a loss of data.\nBuilt-in SQL features such as BEGIN TRANSACTION, COMMIT, and ROLLBACK help avoid some of these race condition problems.\nSQL Injection Attacks\nNow, still considering the code above, you might be wondering what the ? question marks do above. One of the problems that can arise in real-world applications of SQL is what is called an injection attack. An injection attack is where a malicious actor could input malicious SQL code.\nFor example, consider a login screen as follows:\n\nharvard key login screen with username and password fields\n\nWithout the proper protections in our own code, a bad actor could run malicious code. Consider the following:\n\nrows = db.execute(\"SELECT COUNT(*) FROM users WHERE username = ? AND password = ?\", username, password)\nNotice that because the ? is in place, validation can be run on favorite before it is blindly accepted by the query.\n\nYou never want to utilize formatted strings in queries as above or blindly trust the user\u2019s input.\nUtilizing the CS50 Library, the library will sanitize and remove any potentially malicious characters.\nSumming Up\nIn this lesson, you learned more syntax related to Python. Further, you learned how to integrate this knowledge with data in the form of flat-file and relational databases. Finally, you learned about SQL. Specifically, we discussed\u2026\n\nFlat-file databases\nRelational databases\nSQL\nPrimary and foreign keys\nJOINs\nIndexes\nUsing SQL in Python\nRace conditions\nSQL injection attacks\nSee you next time!"
        },
        {
            "lecture": 9,
            "content": "Lecture 9\nWelcome!\nStatic to Dynamic\nFlask\nForms\nLayout\nPOST\nFrosh IMs\nFlask and SQL\nSession\nShopping Cart\nShows\nAJAX and APIs\nJSON\nSumming Up\nWelcome!\nIn previous weeks, you have learned numerous programming languages, techniques, and strategies.\nIndeed, this class has been far less of a C class or Python class and far more of a programming class, such that you can go on to follow future trends.\nIn these past several weeks, you have learned how to learn about programming.\nToday, we will be moving from HTML and CSS into combining HTML, CSS, SQL, Python, and JavaScript so you can create your own web applications.\nStatic to Dynamic\nUp until this point, all HTML you saw was pre-written and static.\nIn the past, when you visited a page, the browser downloaded an HTML page, and you were able to view it. These are considered static pages, in that what programmed in the HTML is exactly what the user sees and downloads to their internet browser.\nDynamic pages refer to the ability of Python and similar languages to create HTML files on-the-fly. Accordingly, you can have web pages that are generated by options selected by your user.\nYou have used http-server in the past to serve your web pages. Today, we are going to utilize a new server that can parse out a web address and perform actions based on the URL provided.\nFlask\nFlask is a third-party library that allows you to host web applications using the Flask framework, or a micro-framework, within Python.\nYou can run flask by executing flask run in your terminal window in cs50.dev.\nTo do so, you will need a file called app.py and a folder called templates.\nTo get started, create a folder called templates and create a file called index.html with the following code:\n<!DOCTYPE html>\n\n<html lang=\"en\">\n    <head>\n        <meta name=\"viewport\" content=\"initial-scale=1, width=device-width\">\n        <title>hello</title>\n    </head>\n    <body>\n        hello, {{ name }}\n    </body>\n</html>\n  \nNotice the double {{ name }} that is a placeholder for something that will be later provided by our Flask server.\n\nThen, in the same folder that the templates folder appears, create a file called app.py and add the following code:\n\n# Uses request.args.get\n\nfrom flask import Flask, render_template, request\n\napp = Flask(__name__)\n\n\n@app.route(\"/\")\ndef index():\n    name = request.args.get(\"name\", \"world\")\n    return render_template(\"index.html\", name=name)\nNotice that this code defines app as the Flask application. Then, it defines the / route of app as returning the contents of index.html with the argument of name. By default, the request.args.get function will look for the name being provided by the user. If no name is provided, it will default to world.\n@app.route is otherwise known as a decorator.\nFinally, add a final file in the same folder as app.py called requirements.txt that has only a single line of code:\n\nFlask\nNotice only Flask appears in this file.\n\nYou can run this file by typing flask run in the terminal window. If Flask does not run, ensure that your syntax is correct in each of the files above. Further, if Flask will not run, make sure your files are organized as follows:\n\n/templates\n    index.html\napp.py\nrequirements.txt\nOnce you get it running, you will be prompted to click a link. Once you navigate to that webpage, try adding ?name=[Your Name] to the base URL in your browser\u2019s URL bar.\nForms\nImproving upon our program, we know that most users will not type arguments into the address bar. Instead, programmers rely upon users to fill out forms on web pages. Accordingly, we can modify index.html as follows:\n\n<!DOCTYPE html>\n\n<html lang=\"en\">\n    <head>\n        <meta name=\"viewport\" content=\"initial-scale=1, width=device-width\">\n        <title>hello</title>\n    </head>\n    <body>\n        <form action=\"/greet\" method=\"get\">\n            <input autocomplete=\"off\" autofocus name=\"name\" placeholder=\"Name\" type=\"text\">\n            <button type=\"submit\">Greet</button>\n        </form>\n    </body>\n</html>\nNotice that a form is now created that takes the user\u2019s name and then passes it off to a route called /greet.\n\nFurther, we can change app.py as follows:\n\n# Adds a form, second route\n\nfrom flask import Flask, render_template, request\n\napp = Flask(__name__)\n\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"index.html\")\n\n\n@app.route(\"/greet\")\ndef greet():\n    return render_template(\"greet.html\", name=request.args.get(\"name\", \"world\"))\nNotice that the default path will display a form for the user to input their name. The /greet route will pass the name to that web page.\n\nTo finalize this implementation, you will need another template for greet.html in the templates folder as follows:\n\n<!DOCTYPE html>\n\n<html lang=\"en\">\n    <head>\n        <meta name=\"viewport\" content=\"initial-scale=1, width=device-width\">\n        <title>hello</title>\n    </head>\n    <body>\n        hello, {{ name }}\n    </body>\n</html>\nNotice that this route will now render the greeting to the user, followed by their name.\n\nLayout\nBoth of our web pages, index.html and greet.html, have much of the same data. Wouldn\u2019t it be nice to allow the body to be unique, but copy the same layout from page to page?\nFirst, create a new template called layout.html and write code as follows:\n\n<!DOCTYPE html>\n\n<html lang=\"en\">\n    <head>\n        <meta name=\"viewport\" content=\"initial-scale=1, width=device-width\">\n        <title>hello</title>\n    </head>\n    <body>\n        {% block body %}{% endblock %}\n    </body>\n</html>\nNotice that the {% block body %}{% endblock %} allows for the insertion of other code from other HTML files.\n\nThen, modify your index.html as follows:\n\n{% extends \"layout.html\" %}\n\n{% block body %}\n\n    <form action=\"/greet\" method=\"get\">\n        <input autocomplete=\"off\" autofocus name=\"name\" placeholder=\"Name\" type=\"text\">\n        <button type=\"submit\">Greet</button>\n    </form>\n\n{% endblock %}\nNotice that the line {% extends \"layout.html\" %} tells the server where to get the layout of this page. Then, the {% block body %}{% endblock %} tells what code to be inserted into layout.html.\n\nFinally, change greet.html as follows:\n\n{% extends \"layout.html\" %}\n\n{% block body %}\n    hello, {{ name }}\n{% endblock %}\nNotice how this code is shorter and more compact.\n\nPOST\nYou can imagine scenarios where it is not safe to utilize get, as usernames and passwords would show up in the URL.\nWe can utilize the method post to help with this problem by modifying app.py as follows:\n\n# Switches to POST\n\nfrom flask import Flask, render_template, request\n\napp = Flask(__name__)\n\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"index.html\")\n\n\n@app.route(\"/greet\", methods=[\"POST\"])\ndef greet():\n    return render_template(\"greet.html\", name=request.form.get(\"name\", \"world\"))\nNotice that POST is added to the /greet route, and that we use request.form.get rather than request.args.get.\n\nThis tells the server to look deeper in the virtual envelope and not reveal the items in post in the URL.\nStill, this code can be advanced further by utilizing a single route for both get and post. To do this, modify app.py as follows:\n\n# Uses a single route\n\nfrom flask import Flask, render_template, request\n\napp = Flask(__name__)\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    if request.method == \"POST\":\n        return render_template(\"greet.html\", name=request.form.get(\"name\", \"world\"))\n    return render_template(\"index.html\")\nNotice that both get and post are done in a single routing. However, request.method is utilized to properly route based upon the type of routing requested by the user.\n\nAccordingly, you can modify your index.html as follows:\n\n{% extends \"layout.html\" %}\n\n{% block body %}\n\n    <form action=\"/\" method=\"post\">\n        <input autocomplete=\"off\" autofocus name=\"name\" placeholder=\"Name\" type=\"text\">\n        <button type=\"submit\">Greet</button>\n    </form>\n\n{% endblock %}\nNotice that the form action is changed.\n\nStill, there is a bug still in this code. With our new implementation, when someone types in no name into the form, Hello, is displayed without a name. We can improve our code by editing app.py as follows:\n\n# Moves default value to template\n\nfrom flask import Flask, render_template, request\n\napp = Flask(__name__)\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    if request.method == \"POST\":\n        return render_template(\"greet.html\", name=request.form.get(\"name\"))\n    return render_template(\"index.html\")\nNotice that name=request.form.get(\"name\")) is changed.\n\nFinally, change greet.html as follows:\n\n{% extends \"layout.html\" %}\n\n{% block body %}\n\n    hello, {% if name %}{{ name }}{% else %}world{% endif %}\n\n{% endblock %}\nNotice how hello, is changed to allow for a default output when no name is identified.\n\nAs we\u2019ve been changing many files, you may wish to compare your final code with our final code.\nFrosh IMs\nFrosh IMs or froshims is a web application that allows students to register for intramural sports.\nClose all your hello related windows and create a folder by typing mkdir froshims in the terminal window. Then, type cd froshims to browse to this folder. Within, create a directory called templates by typing mkdir templates. Finally, type code app.py and write code as follows:\n\n# Implements a registration form using a select menu, validating sport server-side\n\nfrom flask import Flask, render_template, request\n\napp = Flask(__name__)\n\nSPORTS = [\n    \"Basketball\",\n    \"Soccer\",\n    \"Ultimate Frisbee\"\n]\n\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"index.html\", sports=SPORTS)\n\n\n@app.route(\"/register\", methods=[\"POST\"])\ndef register():\n\n    # Validate submission\n    if not request.form.get(\"name\") or request.form.get(\"sport\") not in SPORTS:\n        return render_template(\"failure.html\")\n\n    # Confirm registration\n    return render_template(\"success.html\")\nNotice that a failure option is provided, such that a failure message will be displayed to the user if the name or sport field is not properly filled out.\n\nNext, create a file in the templates folder called index.html by typing code templates/index.html and write code as follows:\n\n{% extends \"layout.html\" %}\n\n{% block body %}\n    <h1>Register</h1>\n    <form action=\"/register\" method=\"post\">\n        <input autocomplete=\"off\" autofocus name=\"name\" placeholder=\"Name\" type=\"text\">\n        <select name=\"sport\">\n            <option disabled selected value=\"\">Sport</option>\n            {% for sport in sports %}\n                <option value=\"{{ sport }}\">{{ sport }}</option>\n            {% endfor %}\n        </select>\n        <button type=\"submit\">Register</button>\n    </form>\n{% endblock %}\nNext, create a file called layout.html by typing code templates/layout.html and write code as follows:\n\n<!DOCTYPE html>\n\n<html lang=\"en\">\n    <head>\n        <meta name=\"viewport\" content=\"initial-scale=1, width=device-width\">\n        <title>froshims</title>\n    </head>\n    <body>\n        {% block body %}{% endblock %}\n    </body>\n</html>\nFourth, create a file in templates called success.html as follows:\n\n{% extends \"layout.html\" %}\n\n{% block body %}\n    You are registered!\n{% endblock %}\nFinally, create a file in templates called failure.html as follows:\n\n{% extends \"layout.html\" %}\n\n{% block body %}\n    You are not registered!\n{% endblock %}\nYou can imagine how we might want to see the various registration options using radio buttons. We can improve index.html as follows:\n\n{% extends \"layout.html\" %}\n\n{% block body %}\n    <h1>Register</h1>\n    <form action=\"/register\" method=\"post\">\n        <input autocomplete=\"off\" autofocus name=\"name\" placeholder=\"Name\" type=\"text\">\n        {% for sport in sports %}\n            <input name=\"sport\" type=\"radio\" value=\"{{ sport }}\"> {{ sport }}\n        {% endfor %}\n        <button type=\"submit\">Register</button>\n    </form>\n{% endblock %}\nExecuting flask run you can see how the interface has now changed.\nWe can further improve upon our program by enabling checkboxes. Modify index.html as follows:\n\n{% extends \"layout.html\" %}\n\n{% block body %}\n    <h1>Register</h1>\n    <form action=\"/register\" method=\"post\">\n        <input autocomplete=\"off\" autofocus name=\"name\" placeholder=\"Name\" type=\"text\">\n        {% for sport in sports %}\n            <input name=\"sport\" type=\"checkbox\" value=\"{{ sport }}\"> {{ sport }}\n        {% endfor %}\n        <button type=\"submit\">Register</button>\n    </form>\n{% endblock %}\nNotice that type is changed to checkbox.\n\nTo implement this, we will need to modify app.py:\n\n# Implements a registration form using checkboxes\n\nfrom flask import Flask, render_template, request\n\napp = Flask(__name__)\n\nSPORTS = [\n    \"Basketball\",\n    \"Soccer\",\n    \"Ultimate Frisbee\"\n]\n\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"index.html\", sports=SPORTS)\n\n\n@app.route(\"/register\", methods=[\"POST\"])\ndef register():\n\n    # Validate submission\n    if not request.form.get(\"name\"):\n        return render_template(\"failure.html\")\n    for sport in request.form.getlist(\"sport\"):\n        if sport not in SPORTS:\n            return render_template(\"failure.html\")\n\n    # Confirm registration\n    return render_template(\"success.html\")\nNotice how for sport in allows iteration through all the sports selected by the user.\n\nYou can imagine how we might want to accept the registration of many different registrants. We can improve app.py as follows:\n\n# Implements a registration form, storing registrants in a dictionary, with error messages\n\nfrom flask import Flask, redirect, render_template, request\n\napp = Flask(__name__)\n\nREGISTRANTS = {}\n\nSPORTS = [\n    \"Basketball\",\n    \"Soccer\",\n    \"Ultimate Frisbee\"\n]\n\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"index.html\", sports=SPORTS)\n\n\n@app.route(\"/register\", methods=[\"POST\"])\ndef register():\n\n    # Validate name\n    name = request.form.get(\"name\")\n    if not name:\n        return render_template(\"error.html\", message=\"Missing name\")\n\n    # Validate sport\n    sport = request.form.get(\"sport\")\n    if not sport:\n        return render_template(\"error.html\", message=\"Missing sport\")\n    if sport not in SPORTS:\n        return render_template(\"error.html\", message=\"Invalid sport\")\n\n    # Remember registrant\n    REGISTRANTS[name] = sport\n\n    # Confirm registration\n    return redirect(\"/registrants\")\n\n\n@app.route(\"/registrants\")\ndef registrants():\n    return render_template(\"registrants.html\", registrants=REGISTRANTS)\nNotice that a dictionary called REGISTRANTS is used to log the sport selected by REGISTRANTS[name]. Also, notice that registrants=REGISTRANTS passes the dictionary on to this template.\n\nAdditionally, we can implement error.html:\n\n{% extends \"layout.html\" %}\n\n{% block body %}\n    <h1>Error</h1>\n    <p>{{ message }}</p>\n    <img alt=\"Grumpy Cat\" src=\"/static/cat.jpg\">\n{% endblock %}\nFurther, create a new template called registrants.html as follows:\n\n{% extends \"layout.html\" %}\n\n{% block body %}\n    <h1>Registrants</h1>\n    <table>\n        <thead>\n            <tr>\n                <th>Name</th>\n                <th>Sport</th>\n            </tr>\n        </thead>\n        <tbody>\n            {% for name in registrants %}\n                <tr>\n                    <td>{{ name }}</td>\n                    <td>{{ registrants[name] }}</td>\n                </tr>\n            {% endfor %}\n        </tbody>\n    </table>\n{% endblock %}\nNotice that {% for name in registrants %}...{% endfor %} will iterate through each of the registrants. Very powerful to be able to iterate on a dynamic web page!\n\nYou now have a web application! However, there are some security flaws! Because everything is client-side, an adversary could change the HTML and hack a website. Further, this data will not persist if the server is shut down. Could there be some way we could have our data persist even when the server restarts?\nFlask and SQL\nJust as we have seen how Python can interface with a SQL database, we can combine the power of Flask, Python, and SQL to create a web application where data will persist!\nTo implement this, you will need to take a number of steps.\nFirst, modify requirements.txt as follows:\n\ncs50\nFlask\nModify index.html as follows:\n\n{% extends \"layout.html\" %}\n\n{% block body %}\n    <h1>Register</h1>\n    <form action=\"/register\" method=\"post\">\n        <input autocomplete=\"off\" autofocus name=\"name\" placeholder=\"Name\" type=\"text\">\n        {% for sport in sports %}\n            <input name=\"sport\" type=\"radio\" value=\"{{ sport }}\"> {{ sport }}\n        {% endfor %}\n        <button type=\"submit\">Register</button>\n    </form>\n{% endblock %}\nModify layout.html as follows:\n\n<!DOCTYPE html>\n\n<html lang=\"en\">\n    <head>\n        <meta name=\"viewport\" content=\"initial-scale=1, width=device-width\">\n        <title>froshims</title>\n    </head>\n    <body>\n        {% block body %}{% endblock %}\n    </body>\n</html>\nEnsure failure.html appears as follows:\n\n{% extends \"layout.html\" %}\n\n{% block body %}\n    You are not registered!\n{% endblock %}\nModify registrants.html to appear as follows:\n\n{% extends \"layout.html\" %}\n\n{% block body %}\n    <h1>Registrants</h1>\n    <table>\n        <thead>\n            <tr>\n                <th>Name</th>\n                <th>Sport</th>\n                <th></th>\n            </tr>\n        </thead>\n        <tbody>\n            {% for registrant in registrants %}\n                <tr>\n                    <td>{{ registrant.name }}</td>\n                    <td>{{ registrant.sport }}</td>\n                    <td>\n                        <form action=\"/deregister\" method=\"post\">\n                            <input name=\"id\" type=\"hidden\" value=\"{{ registrant.id }}\">\n                            <button type=\"submit\">Deregister</button>\n                        </form>\n                    </td>\n                </tr>\n            {% endfor %}\n        </tbody>\n    </table>\n{% endblock %}\nNotice that a hidden value registrant.id is included such that it\u2019s possible to use this id later in app.py\n\nFinally, modify app.py as follows:\n\n# Implements a registration form, storing registrants in a SQLite database, with support for deregistration\n\nfrom cs50 import SQL\nfrom flask import Flask, redirect, render_template, request\n\napp = Flask(__name__)\n\ndb = SQL(\"sqlite:///froshims.db\")\n\nSPORTS = [\n    \"Basketball\",\n    \"Soccer\",\n    \"Ultimate Frisbee\"\n]\n\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"index.html\", sports=SPORTS)\n\n\n@app.route(\"/deregister\", methods=[\"POST\"])\ndef deregister():\n\n    # Forget registrant\n    id = request.form.get(\"id\")\n    if id:\n        db.execute(\"DELETE FROM registrants WHERE id = ?\", id)\n    return redirect(\"/registrants\")\n\n\n@app.route(\"/register\", methods=[\"POST\"])\ndef register():\n\n    # Validate submission\n    name = request.form.get(\"name\")\n    sport = request.form.get(\"sport\")\n    if not name or sport not in SPORTS:\n        return render_template(\"failure.html\")\n\n    # Remember registrant\n    db.execute(\"INSERT INTO registrants (name, sport) VALUES(?, ?)\", name, sport)\n\n    # Confirm registration\n    return redirect(\"/registrants\")\n\n\n@app.route(\"/registrants\")\ndef registrants():\n    registrants = db.execute(\"SELECT * FROM registrants\")\n    return render_template(\"registrants.html\", registrants=registrants)\nNotice that the cs50 library is utilized. A route is included for register for the post method. This route will take the name and sport taken from the registration form and execute a SQL query to add the name and the sport to the registrants table. The deregister routes to a SQL query that will grab the user\u2019s id and utilize that information to deregister this individual.\n\nYou can read more in the Flask documentation.\nSession\nWhile the above code is useful from an administrative standpoint, where a back-office administrator could add and remove individuals from the database, one can imagine how this code is not safe to implement on a public server.\nFor one, bad actors could make decisions on behalf of other users by hitting the deregister button \u2013 effectively deleting their recorded answer from the server.\nWeb services like Google use login credentials to ensure users only have access to the right data.\nWe can actually implement this itself using cookies. Cookies are small files that are stored on your computer, such that your computer can communicate with the server and effectively say, \u201cI\u2019m an authorized user that has already logged in.\u201d This authorization through this cookie is called a session.\nIn the simplest form, we can implement this by creating a folder called login and then adding the following files.\nFirst, create a file called requirements.txt that reads as follows:\n\nFlask\nFlask-Session\nNotice that in addition to Flask, we also include Flask-Session, which is required to support login sessions.\n\nSecond, in a templates folder, create a file called layout.html that appears as follows:\n\n<!DOCTYPE html>\n\n<html lang=\"en\">\n    <head>\n        <meta name=\"viewport\" content=\"initial-scale=1, width=device-width\">\n        <title>login</title>\n    </head>\n    <body>\n        {% block body %}{% endblock %}\n    </body>\n</html>\nNotice this provides a very simple layout with a title and a body.\n\nThird, create a file in the templates folder called index.html that appears as follows:\n\n{% extends \"layout.html\" %}\n\n{% block body %}\n\n    {% if name %}\n        You are logged in as {{ name }}. <a href=\"/logout\">Log out</a>.\n    {% else %}\n        You are not logged in. <a href=\"/login\">Log in</a>.\n    {% endif %}\n\n{% endblock %}\nNotice that this file looks to see if session[\"name\"] exists (elaborated further in app.py below). If it does, it will display a welcome message. If not, it will recommend you browse to a page to log in.\n\nFourth, create a file called login.html and add the following code:\n\n{% extends \"layout.html\" %}\n\n{% block body %}\n\n    <form action=\"/login\" method=\"post\">\n        <input autocomplete=\"off\" autofocus name=\"name\" placeholder=\"Name\" type=\"text\">\n        <button type=\"submit\">Log In</button>\n    </form>\n\n{% endblock %}\nNotice this is the layout of a basic login page.\n\nFinally, create a file called app.py and write code as follows:\n\nfrom flask import Flask, redirect, render_template, request, session\nfrom flask_session import Session\n\n# Configure app\napp = Flask(__name__)\n\n# Configure session\napp.config[\"SESSION_PERMANENT\"] = False\napp.config[\"SESSION_TYPE\"] = \"filesystem\"\nSession(app)\n\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"index.html\", name=session.get(\"name\"))\n\n\n@app.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef login():\n    if request.method == \"POST\":\n        session[\"name\"] = request.form.get(\"name\")\n        return redirect(\"/\")\n    return render_template(\"login.html\")\n\n\n@app.route(\"/logout\")\ndef logout():\n    session.clear()\n    return redirect(\"/\")\nNotice the modified imports at the top of the file, including session, which will allow for you to support sessions. Most important, notice how session[\"name\"] is used in the login and logout routes. The login route will assign the login name provided and assign it to session[\"name\"]. However, in the logout route, the logging out is implemented by clearing the value of session.\n\nYou can read more about sessions in the Flask documentation.\nShopping Cart\nMoving on to a final example of utilizing Flask\u2019s ability to enable a session.\nWe examined the following code for store in app.py. The following code was shown:\n\nfrom cs50 import SQL\nfrom flask import Flask, redirect, render_template, request, session\nfrom flask_session import Session\n\n# Configure app\napp = Flask(__name__)\n\n# Connect to database\ndb = SQL(\"sqlite:///store.db\")\n\n# Configure session\napp.config[\"SESSION_PERMANENT\"] = False\napp.config[\"SESSION_TYPE\"] = \"filesystem\"\nSession(app)\n\n\n@app.route(\"/\")\ndef index():\n    books = db.execute(\"SELECT * FROM books\")\n    return render_template(\"books.html\", books=books)\n\n\n@app.route(\"/cart\", methods=[\"GET\", \"POST\"])\ndef cart():\n\n    # Ensure cart exists\n    if \"cart\" not in session:\n        session[\"cart\"] = []\n\n    # POST\n    if request.method == \"POST\":\n        book_id = request.form.get(\"id\")\n        if book_id:\n            session[\"cart\"].append(book_id)\n        return redirect(\"/cart\")\n\n    # GET\n    books = db.execute(\"SELECT * FROM books WHERE id IN (?)\", session[\"cart\"])\n    return render_template(\"cart.html\", books=books)\nNotice that cart is implemented using a list. Items can be added to this list using the Add to Cart buttons in books.html. When clicking such a button, the post method is invoked, where the id of the item is appended to the cart. When viewing the cart, invoking the get method, SQL is executed to display a list of the books in the cart.\n\nYou can see the rest of the files that power this flask implementation in the source code.\nShows\nWe looked at a pre-designed program called shows, in app.py:\n\n# Searches for shows using LIKE\n\nfrom cs50 import SQL\nfrom flask import Flask, render_template, request\n\napp = Flask(__name__)\n\ndb = SQL(\"sqlite:///shows.db\")\n\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"index.html\")\n\n\n@app.route(\"/search\")\ndef search():\n    shows = db.execute(\"SELECT * FROM shows WHERE title LIKE ?\", \"%\" + request.args.get(\"q\") + \"%\")\n    return render_template(\"search.html\", shows=shows)\nNotice how the search route allows for a way by which to search for a show. This search looks for titles LIKE the one provided by the user.\n\nYou can see the rest of the files of this implementation in the source code.\n\nAJAX and APIs\nAn application program interface or API is a series of specifications that allow you to interface with another service. For example, we could utilize IMDB\u2019s API to interface with their database. We might even integrate APIs for handling specific types of data downloadable from a server.\nImproving upon shows, looking at an improvement of app.py, we saw the following:\n\n# Searches for shows using Ajax\n\nfrom cs50 import SQL\nfrom flask import Flask, render_template, request\n\napp = Flask(__name__)\n\ndb = SQL(\"sqlite:///shows.db\")\n\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"index.html\")\n\n\n@app.route(\"/search\")\ndef search():\n    q = request.args.get(\"q\")\n    if q:\n        shows = db.execute(\"SELECT * FROM shows WHERE title LIKE ? LIMIT 50\", \"%\" + q + \"%\")\n    else:\n        shows = []\n    return render_template(\"search.html\", shows=shows)\nNotice that the search route executes a SQL query.\n\nLooking at search.html, you\u2019ll notice that it is very simple:\n\n{% for show in shows %}\n    <li>{{ show[\"title\"] }}</li>\n{% endfor %}\nNotice that it provides a bulleted list.\n\nFinally, looking at index.html, notice that AJAX code is utilized to power the search:\n\n<!DOCTYPE html>\n\n<html lang=\"en\">\n    <head>\n        <meta name=\"viewport\" content=\"initial-scale=1, width=device-width\">\n        <title>shows</title>\n    </head>\n    <body>\n\n        <input autocomplete=\"off\" autofocus placeholder=\"Query\" type=\"search\">\n\n        <ul></ul>\n\n        <script>\n      \n            let input = document.querySelector('input');\n            input.addEventListener('input', async function() {\n                let response = await fetch('/search?q=' + input.value);\n                let shows = await response.text();\n                document.querySelector('ul').innerHTML = shows;\n            });\n\n        </script>\n\n    </body>\n</html>\nNotice an event listener is utilized to dynamically query the server to provide a list that matches the title provided. This will locate the ul tag in the HTML and modify the web page accordingly to include the list of the matches.\n\nYou can read more in the AJAX documentation.\nJSON\nJavaScript Object Notation or JSON is text file of dictionaries with keys and values. This is a raw, computer-friendly way to get lots of data.\nJSON is a very useful way of getting back data from the server.\nYou can see this in action in the index.html we examined together:\n\n<!DOCTYPE html>\n\n<html lang=\"en\">\n    <head>\n        <meta name=\"viewport\" content=\"initial-scale=1, width=device-width\">\n        <title>shows</title>\n    </head>\n    <body>\n\n        <input autocomplete=\"off\" autofocus placeholder=\"Query\" type=\"text\">\n\n        <ul></ul>\n\n        <script>\n      \n            let input = document.querySelector('input');\n            input.addEventListener('input', async function() {\n                let response = await fetch('/search?q=' + input.value);\n                let shows = await response.json();\n                let html = '';\n                for (let id in shows) {\n                    let title = shows[id].title.replace('<', '&lt;').replace('&', '&amp;');\n                    html += '<li>' + title + '</li>';\n                }\n                document.querySelector('ul').innerHTML = html;\n            });\n\n        </script>\n\n    </body>\n</html>\nWhile the above may be somewhat cryptic, it provides a starting point for you to research JSON on your own to see how it can be implemented in your own web applications.\n\nFurther, we examined app.py to see how the JSON response is obtained:\n\n# Searches for shows using Ajax with JSON\n\nfrom cs50 import SQL\nfrom flask import Flask, jsonify, render_template, request\n\napp = Flask(__name__)\n\ndb = SQL(\"sqlite:///shows.db\")\n\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"index.html\")\n\n\n@app.route(\"/search\")\ndef search():\n    q = request.args.get(\"q\")\n    if q:\n        shows = db.execute(\"SELECT * FROM shows WHERE title LIKE ? LIMIT 50\", \"%\" + q + \"%\")\n    else:\n        shows = []\n    return jsonify(shows)\nNotice how jsonify is used to convert the result into a readable format acceptible by contemporary web applications.\n\nYou can read more in the JSON documentation.\nSumming Up\nIn this lesson, you learned how to utilize Python, SQL, and Flask to create web applications. Specifically, we discussed\u2026\n\nGET\nPOST\nFlask\nSession\nAPIs\nAJAX\nJSON\nSee you next time for our final lecture!"
        },
        {
            "lecture": 8,
            "content": "Lecture 8\nWelcome!\nRouters\nDNS\nHTTP\nHTML\nRegular Expressions\nCSS\nFrameworks\nJavaScript\nSumming Up\nWelcome!\nIn previous weeks, we introduced you to Python, a high-level programming language that utilized the same building blocks we learned in C. Today, we will extend those building blocks further in HTML, CSS, and JavaScript.\nThe internet is a technology that we all use.\nUsing our skills from previous weeks, we can build our own web pages and applications.\nThe ARPANET connected the first points on the internet to one another.\nDots between two points could be considered routers.\nRouters\nTo route data from one place to another, we need to make routing decisions. That is, someone needs to program how data is transferred from point A to point B.\nYou can imagine how data could take multiple paths from point A and point B, such that when a router is congested, data can flow through another path. Packets of data are transferred from one router to another, from one computer to another.\nTCP/IP are two protocols that allow computers to transfer data between them over the internet.\nIP or internet protocol is a way by which computers can identify one another across the internet. Every computer has a unique address in the world. Addresses are in this form:\n\n  #.#.#.#\nNumbers range from 0 to 255. IP addresses are 32-bits, meaning that these addresses could accommodate over 4 billion addresses. Newer versions of IP addresse, implementing 128-bits, can accommodate far more computers!\nIn the real world, servers do a lot of work for us.\nPackets are structured as follows:\n\nascii art of a packet\n\nPackets are standardized. The source and destination are held within each packet.\nTCP, or transmission control protocol, is used to distinguish web services from one another. For example, 80 is used to denote HTTP and 443 is used to denote HTTPS. These numbers are port numbers.\nWhen information is sent from one location to another, a source IP address, a destination IP address, and TCP port number are sent.\nThese protocols are also used to fragment large files into multiple parts or packets. For example, a large photo of a cat can be sent in multiple packets. When a packet is lost, TCP/IP can request missing packets again from the origin server.\nTCP will acknowledge when all the data has been transmitted and received.\nDNS\nIt would be very tedious if you needed to remember an IP address to visit a website.\nDNS, or domain name systems, is a collection of servers on the internet that are used to route website addresses like harvard.edu to a specific IP address.\nDNS simply hold a table or database that links specific, fully qualified domain names to specific IP addresses.\nHTTP\nHTTP or hypertext transfer protocol is an application-level protocol that developers use to build powerful and useful things through the transferring of data from one place to another.\nWhen you see an address such as https://www.example.com you are actually implicitly visiting that address with a / at the end of it.\nThe path is what exists after that slash. For example, https://www.example.com/folder/file.html visits example.com and browses to the folder folder and then visits the file named file.html.\nThe .com is called a top-level domain that is used to denote the location or type of organization associated with this address.\nhttps in this address is the protocol that is used to connect to that web address. By protocol, we mean that HTTP utilizes GET or POST requests to ask for information from a server. For example, you can launch Google Chrome, right-click, and click inspect. When you open the developer tools and visit Network, selecting Preserve log, you will see Request Headers. You\u2019ll see mentions of GET. This is possible in other browsers as well, using slightly different methods.\nFor example, when issuing a GET request, your computer may send the following to a server:\n\n  GET / HTTP/2\n  Host: www.harvard.edu\nNotice that this requests via HTTP the content served on www.harvard.edu\n\nGenerally, after making a request a server, you will receive the following in Response Headers:\n\n  HTTP/2 200\n  Content-Type: text/html\nThis approach to inspecting these logs may be a bit more complicated than need be. You can analyze the work of HTTP protocols at cs50.dev. For example, type the following in your terminal window:\n\n  curl -I https://www.harvard.edu/\nNotice that the output of this command returns all the header values of the responses of the server.\n\nVia developer tools in your web browser, you can see all the HTTP requests when browsing to the above website.\nFurther, execute the following command in your terminal window:\n\n  curl -I https://harvard.edu\nNotice that you will see a 301 response, providing a hint to a browser of where it can find the correct website.\n\nSimilarly, execute the following in your terminal window:\n\n  curl -I http://www.harvard.edu/\nNotice that the s in https has been removed. The server response will show that the response is 301, meaning that the website has permanently moved.\n\nSimilar to 301, a code of 404 means that a specified URL has not been found. There are numerous other response codes, such as:\n\n  200 OK\n  301 Moved Permanently\n  302 Found\n  304 Not Modified\n  304 Temporary Redirect\n  401 Unauthorized\n  403 Forbidden\n  404 Not Found\n  418 I'm a Teapot\n  500 Internal Server Error\n  503 Service Unavailable\nIt\u2019s worth mentioning that 500 errors are always your fault as the developer. This will be especially important for next week\u2019s problem set, and potentially for your final project!\nHTML\nHTML or hypertext markup language is made up of tags, each of which may have some attributes that describe it.\nIn your terminal, type code hello.html and write code as follows:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates HTML -->\n\n<html lang=\"en\">\n    <head>\n        <title>hello, title</title>\n    </head>\n    <body>\n        hello, body\n    </body>\n</html>\nNotice that the html tag both opens and closes this file. Further, notice the lang attribute, which modifies the behavior of the html tag. Also, notice that there are both head tags and body tags. Indentation is not required but does suggest a hierarchy.\n\nYou can serve your code by typing http-server. This serve is now available on a very long URL. If you click it, you can visit the website with your own code.\nWhen you visit this URL, notice that the file name hello.html appears at the end of this URL. Further, notice, based upon the URL, that the server is serving via port 8080.\nThe hierarchy of tags can be represented as follows:\n\nhtml code next to a hierarchy showing parent and child nodes\n\nKnowledge of this hierarchy will be useful later as we learn JavaScript.\nThe browser will read your HTML file top to bottom and left to right.\nBecause whitespace and indentation is effectively ignored in HTML, you will need to use <p> paragraph tags to open and close a paragraph. Consider the following:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates paragraphs -->\n\n<html lang=\"en\">\n    <head>\n        <title>paragraphs</title>\n    </head>\n    <body>\n        <p>\n            Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus convallis scelerisque quam, vel hendrerit lectus viverra eu. Praesent posuere eget lectus ut faucibus. Etiam eu velit laoreet, gravida lorem in, viverra est. Cras ut purus neque. In porttitor non lorem id lobortis. Mauris gravida metus libero, quis maximus dui porta at. Donec lacinia felis consectetur venenatis scelerisque. Nulla eu nisl sollicitudin, varius velit sit amet, vehicula erat. Curabitur sollicitudin felis sit amet orci mattis, a tempus nulla pulvinar. Aliquam erat volutpat.\n        </p>\n        <p>\n            Mauris ut dui in eros semper hendrerit. Morbi vel elit mi. Sed sit amet ex non quam dignissim dignissim et vel arcu. Pellentesque eget elementum orci. Morbi ac cursus ex. Pellentesque quis turpis blandit orci dapibus semper sed non nunc. Nulla et dolor nec lacus finibus volutpat. Sed non lorem diam. Donec feugiat interdum interdum. Vivamus et justo in enim blandit fermentum vel at elit. Phasellus eu ante vitae ligula varius aliquet. Etiam id posuere nibh.\n        </p>\n        <p>\n            Aenean venenatis convallis ante a rhoncus. Nullam in metus vel diam vehicula tincidunt. Donec lacinia metus sem, sit amet egestas elit blandit sit amet. Nunc egestas sem quis nisl mattis semper. Pellentesque ut magna congue lorem eleifend sodales. Donec tortor tortor, aliquam vitae mollis sed, interdum ut lectus. Mauris non purus quis ipsum lacinia tincidunt.\n        </p>\n        <p>\n            Integer at justo lacinia libero blandit aliquam ut ut dui. Quisque tincidunt facilisis venenatis. Nullam dictum odio quis lorem luctus, vel malesuada dolor luctus. Aenean placerat faucibus enim a facilisis. Maecenas eleifend quis massa sed eleifend. Ut ultricies, dui ac vulputate hendrerit, ex metus iaculis diam, vitae fermentum libero dui et ante. Phasellus suscipit, arcu ut consequat sagittis, massa urna accumsan massa, eu aliquet nulla lorem vitae arcu. Pellentesque rutrum felis et metus porta semper. Nam ac consectetur mauris.\n        </p>\n        <p>\n            Suspendisse rutrum vestibulum odio, sed venenatis purus condimentum sed. Morbi ornare tincidunt augue eu auctor. Vivamus sagittis ac lectus at aliquet. Nulla urna mauris, interdum non nibh in, vehicula porta enim. Donec et posuere sapien. Pellentesque ultrices scelerisque ipsum, vel fermentum nibh tincidunt et. Proin gravida porta ipsum nec scelerisque. Vestibulum fringilla erat at turpis laoreet, nec hendrerit nisi scelerisque.\n        </p>\n        <p>\n            Sed quis malesuada mi. Nam id purus quis augue sagittis pharetra. Nulla facilisi. Maecenas vel fringilla ante. Cras tristique, arcu sit amet blandit auctor, urna elit ultricies lacus, a malesuada eros dui id massa. Aliquam sem odio, pretium vel cursus eget, scelerisque at urna. Vestibulum posuere a turpis consectetur consectetur. Cras consequat, risus quis tempor egestas, nulla ipsum ornare erat, nec accumsan nibh lorem nec risus. Integer at iaculis lacus. Integer congue nunc massa, quis molestie felis pellentesque vestibulum. Nulla odio tortor, aliquam nec quam in, ornare aliquet sapien.\n        </p>\n    </body>\n</html>\nNotice that paragraphs start with a <p> tag and end with a </p> tag.\n\nHTML allows for the representation of headings:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates headings (for chapters, sections, subsections, etc.) -->\n\n<html lang=\"en\">\n\n    <head>\n        <title>headings</title>\n    </head>\n\n    <body>\n\n        <h1>One</h1>\n        <p>\n            Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus convallis scelerisque quam, vel hendrerit lectus viverra eu. Praesent posuere eget lectus ut faucibus. Etiam eu velit laoreet, gravida lorem in, viverra est. Cras ut purus neque. In porttitor non lorem id lobortis. Mauris gravida metus libero, quis maximus dui porta at. Donec lacinia felis consectetur venenatis scelerisque. Nulla eu nisl sollicitudin, varius velit sit amet, vehicula erat. Curabitur sollicitudin felis sit amet orci mattis, a tempus nulla pulvinar. Aliquam erat volutpat.\n        </p>\n\n        <h2>Two</h2>\n        <p>\n            Mauris ut dui in eros semper hendrerit. Morbi vel elit mi. Sed sit amet ex non quam dignissim dignissim et vel arcu. Pellentesque eget elementum orci. Morbi ac cursus ex. Pellentesque quis turpis blandit orci dapibus semper sed non nunc. Nulla et dolor nec lacus finibus volutpat. Sed non lorem diam. Donec feugiat interdum interdum. Vivamus et justo in enim blandit fermentum vel at elit. Phasellus eu ante vitae ligula varius aliquet. Etiam id posuere nibh.\n        </p>\n\n        <h3>Three</h3>\n        <p>\n            Aenean venenatis convallis ante a rhoncus. Nullam in metus vel diam vehicula tincidunt. Donec lacinia metus sem, sit amet egestas elit blandit sit amet. Nunc egestas sem quis nisl mattis semper. Pellentesque ut magna congue lorem eleifend sodales. Donec tortor tortor, aliquam vitae mollis sed, interdum ut lectus. Mauris non purus quis ipsum lacinia tincidunt.\n        </p>\n\n        <h4>Four</h4>\n        <p>\n            Integer at justo lacinia libero blandit aliquam ut ut dui. Quisque tincidunt facilisis venenatis. Nullam dictum odio quis lorem luctus, vel malesuada dolor luctus. Aenean placerat faucibus enim a facilisis. Maecenas eleifend quis massa sed eleifend. Ut ultricies, dui ac vulputate hendrerit, ex metus iaculis diam, vitae fermentum libero dui et ante. Phasellus suscipit, arcu ut consequat sagittis, massa urna accumsan massa, eu aliquet nulla lorem vitae arcu. Pellentesque rutrum felis et metus porta semper. Nam ac consectetur mauris.\n        </p>\n\n        <h5>Five</h5>\n        <p>\n            Suspendisse rutrum vestibulum odio, sed venenatis purus condimentum sed. Morbi ornare tincidunt augue eu auctor. Vivamus sagittis ac lectus at aliquet. Nulla urna mauris, interdum non nibh in, vehicula porta enim. Donec et posuere sapien. Pellentesque ultrices scelerisque ipsum, vel fermentum nibh tincidunt et. Proin gravida porta ipsum nec scelerisque. Vestibulum fringilla erat at turpis laoreet, nec hendrerit nisi scelerisque.\n        </p>\n\n        <h6>Six</h6>\n        <p>\n            Sed quis malesuada mi. Nam id purus quis augue sagittis pharetra. Nulla facilisi. Maecenas vel fringilla ante. Cras tristique, arcu sit amet blandit auctor, urna elit ultricies lacus, a malesuada eros dui id massa. Aliquam sem odio, pretium vel cursus eget, scelerisque at urna. Vestibulum posuere a turpis consectetur consectetur. Cras consequat, risus quis tempor egestas, nulla ipsum ornare erat, nec accumsan nibh lorem nec risus. Integer at iaculis lacus. Integer congue nunc massa, quis molestie felis pellentesque vestibulum. Nulla odio tortor, aliquam nec quam in, ornare aliquet sapien.\n        </p>\n\n    </body>\n\n</html>\nNotice that <h1>, <h2>, and <h3> denote different levels of headings.\n\nWe can also create unordered lists within HTML:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates (ordered) lists -->\n\n<html lang=\"en\">\n    <head>\n        <title>list</title>\n    </head>\n    <body>\n        <ul>\n            <li>foo</li>\n            <li>bar</li>\n            <li>baz</li>\n        </ul>\n    </body>\n</html>\nNotice that the <ul> tag creates an unordered list containing three items.\n\nWe can also create ordered lists within HTML:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates (ordered) lists -->\n\n<html lang=\"en\">\n    <head>\n        <title>list</title>\n    </head>\n    <body>\n        <ol>\n            <li>foo</li>\n            <li>bar</li>\n            <li>baz</li>\n        </ol>\n    </body>\n</html>\nNotice that the <ol> tag creates an ordered list containing three items.\n\nWe can also create a table in HTML:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates table -->\n\n<html lang=\"en\">\n    <head>\n        <title>table</title>\n    </head>\n    <body>\n        <table>\n            <tr>\n                <td>1</td>\n                <td>2</td>\n                <td>3</td>\n            </tr>\n            <tr>\n                <td>4</td>\n                <td>5</td>\n                <td>6</td>\n            </tr>\n            <tr>\n                <td>7</td>\n                <td>8</td>\n                <td>9</td>\n            </tr>\n            <tr>\n                <td>*</td>\n                <td>0</td>\n                <td>#</td>\n            </tr>\n        </table>\n    </body>\n</html>\nTables also have tags that open and close each element within. Also, notice the syntax for comments in HTML.\n\nImages can also be utilized within HTML:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates image -->\n\n<html lang=\"en\">\n    <head>\n        <title>image</title>\n    </head>\n    <body>\n        <img alt=\"photo of bridge\" src=\"bridge.png\">\n    </body>\n</html>\nNotice that src=\"bridge.png\" indicates the path where the image file can be located.\n\nVideos can also be included in HTML:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates video -->\n\n<html lang=\"en\">\n    <head>\n        <title>video</title>\n    </head>\n    <body>\n        <video controls muted>\n            <source src=\"video.mp4\" type=\"video/mp4\">\n        </video>\n    </body>\n</html>\nNotice that the type attribute designates that this is a video of type mp4. Further, notice how controls and muted are passed to video.\n\nYou can also link between various web pages:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates link -->\n\n<html lang=\"en\">\n    <head>\n        <title>link</title>\n    </head>\n    <body>\n       Visit <a href=\"https://www.harvard.edu\">Harvard</a>.\n    </body>\n</html>\nNotice that the <a> or anchor tag is used to make Harvard a linkable text.\n\nMeta tags are used to hold information about the data within the HTML file. Consider the following:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates responsive design -->\n\n<html lang=\"en\">\n    <head>\n        <meta name=\"viewport\" content=\"initial-scale=1, width=device-width\">\n        <title>meta</title>\n    </head>\n    <body>\n        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus convallis scelerisque quam, vel hendrerit lectus viverra eu. Praesent posuere eget lectus ut faucibus. Etiam eu velit laoreet, gravida lorem in, viverra est. Cras ut purus neque. In porttitor non lorem id lobortis. Mauris gravida metus libero, quis maximus dui porta at. Donec lacinia felis consectetur venenatis scelerisque. Nulla eu nisl sollicitudin, varius velit sit amet, vehicula erat. Curabitur sollicitudin felis sit amet orci mattis, a tempus nulla pulvinar. Aliquam erat volutpat.\n    </body>\n</html>\nNotice this set of meta attributes makes this page mobile-friendly.\n\nThere are numerous meta key-value pairs that you can use:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates Open Graph tags -->\n\n<html lang=\"en\">\n    <head>\n        <meta property=\"og:title\" content=\"CS50\">\n        <meta property=\"og:description\" content=\"Introduction to the intellectual enterprises of computer science and the art of programming.\">\n        <meta property=\"og:image\" content=\"cat.jpg\">\n        <title>meta</title>\n    </head>\n    <body>\n        ...\n    </body>\n</html>\nNotice that these key value pairs relate to the title and description of the web page.\n\nYou can also create forms reminiscent of Google\u2019s search:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates form -->\n\n<html lang=\"en\">\n    <head>\n        <title>search</title>\n    </head>\n    <body>\n        <form action=\"https://www.google.com/search\" method=\"get\">\n            <input name=\"q\" type=\"search\">\n            <input type=\"submit\" value=\"Google Search\">\n        </form>\n    </body>\n</html>\nNotice that a form tag opens and provides the attribute of what action it will take. The input field is included, passing the name q and the type as search.\n\nWe can make this search better as follows:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates additional form attributes -->\n\n<html lang=\"en\">\n    <head>\n        <title>search</title>\n    </head>\n    <body>\n        <form action=\"https://www.google.com/search\" method=\"get\">\n            <input autocomplete=\"off\" autofocus name=\"q\" placeholder=\"Query\" type=\"search\">\n            <button>Google Search</button>\n        </form>\n    </body>\n</html>\nNotice that autocomplete is turned off. autofocus is enabled.\n\nWe\u2019ve seen just a few of many HTML elements you can add to your site. If you have an idea for something to add to your site that we haven\u2019t seen yet (a button, an audio file, etc.) try Googling \u201cX in HTML\u201d to find the right syntax! Similarly, you can use cs50.ai to help you discover more HTML features!\nRegular Expressions\nRegular expressions or regexes are a means by which to ensure that user-provided data fits a specific format.\nWe can impelement our own registration page that utilizes regexes as follows:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates type=\"email\" -->\n\n<html lang=\"en\">\n    <head>\n        <title>register</title>\n    </head>\n    <body>\n        <form>\n            <input autocomplete=\"off\" autofocus name=\"email\" placeholder=\"Email\" type=\"email\">\n            <button>Register</button>\n        </form>\n    </body>\n</html>\nNotice that the input tag includes attributes that designate that this is of type email. The browser knows to double-check that input is an email address.\n\nWhile the browser uses these built-in attributes to check for an email address, we can add a pattern attribute to ensure that only specific data ends up in the email address:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates pattern attribute -->\n\n<html lang=\"en\">\n    <head>\n        <title>register</title>\n    </head>\n    <body>\n        <form>\n            <input autocomplete=\"off\" autofocus name=\"email\" pattern=\".+@.+\\.edu\" placeholder=\"Email\" type=\"email\">\n            <button>Register</button>\n        </form>\n    </body>\n</html>\nNotice that the pattern attribute is handed a regular expression to denote that the email address must include an @ symbol and a .edu.\n\nYou can learn more about regular expressions from Mozilla\u2019s documentation. Further, you can make inquiries to cs50.ai for hints.\nCSS\nCSS, or cascading style sheet, is a markup language that allows you to fine-tune the aesthetics of your HTML files.\nCSS is filled with properties, which include key-value pairs.\nIn your terminal, type code home.html and write code as follows:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates inline CSS with P tags -->\n\n<html lang=\"en\">\n    <head>\n        <title>css</title>\n    </head>\n    <body>\n        <p style=\"font-size: large; text-align: center;\">\n            John Harvard\n        </p>\n        <p style=\"font-size: medium; text-align: center;\">\n            Welcome to my home page!\n        </p>\n        <p style=\"font-size: small; text-align: center;\">\n            Copyright &#169; John Harvard\n        </p>\n    </body>\n</html>\nNotice that some style attributes are provided to the <p> tags. The font-size is set to large, medium, or small. Then text-align is set to center.\n\nWhile correct, the above is not well-designed. We can remove redundancy by modifying our code as follows:\n\n<!DOCTYPE html>\n\n<!-- Removes outer DIV -->\n\n<html lang=\"en\">\n    <head>\n        <title>css</title>\n    </head>\n    <body style=\"text-align: center\">\n        <div style=\"font-size: large\">\n            John Harvard\n        </div>\n        <div style=\"font-size: medium\">\n            Welcome to my home page!\n        </div>\n        <div style=\"font-size: small\">\n            Copyright &#169; John Harvard\n        </div>\n    </body>\n</html>\nNotice that <div> tags are used to divide up this HTML file into specific regions. text-align: center is invoked on the entire body of the HTML. Because everything inside body is a child of body, the center attribute cascades down to those children.\n\nIt turns out that there are newer semantic tags that are included in HTML. We can modify our code as follows:\n\n<!DOCTYPE html>\n\n<!-- Uses semantic tags instead of DIVs -->\n\n<html lang=\"en\">\n    <head>\n        <title>css</title>\n    </head>\n    <body style=\"text-align: center\">\n        <header style=\"font-size: large\">\n            John Harvard\n        </header>\n        <main style=\"font-size: medium\">\n            Welcome to my home page!\n        </main>\n        <footer style=\"font-size: small\">\n            Copyright &#169; John Harvard\n        </footer>\n    </body>\n</html>\nNotice that the header and footer both have different styles assigned to them.\n\nThis practice of placing the style and information all in the same location is not good practice. We could move the elements of style to the top of the file as follows:\n\n<!-- Demonstrates class selectors -->\n\n<html lang=\"en\">\n    <head>\n        <style>\n\n            .centered\n            {\n                text-align: center;\n            }\n\n            .large\n            {\n                font-size: large;\n            }\n\n            .medium\n            {\n                font-size: medium;\n            }\n\n            .small\n            {\n                font-size: small;\n            }\n\n        </style>\n        <title>css</title>\n    </head>\n    <body class=\"centered\">\n        <header class=\"large\">\n            John Harvard\n        </header>\n        <main class=\"medium\">\n            Welcome to my home page!\n        </main>\n        <footer class=\"small\">\n            Copyright &#169; John Harvard\n        </footer>\n    </body>\n</html>\nNotice all the style tags are placed up in the head in the style tag wrapper. Also notice that we\u2019ve assigned classes, called centered, large, medium, and small to our elements, and that we select those classes by placing a dot before the name, as in .centered\n\nIt turns out that we can move all our style code into a special file called a CSS file. We can create a file called style.css and paste our classes there:\n\n.centered\n{\n    text-align: center;\n}\n\n.large\n{\n    font-size: large;\n}\n\n.medium\n{\n    font-size: medium;\n}\n\n.small\n{\n    font-size: small;\n}\nNotice that this is verbatim what appeared in our HTML file.\n\nWe then can tell the browser where to locate the CSS for this HTML file:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates external stylesheets -->\n\n<html lang=\"en\">\n    <head>\n        <link href=\"style.css\" rel=\"stylesheet\">\n        <title>css</title>\n    </head>\n    <body class=\"centered\">\n        <header class=\"large\">\n            John Harvard\n        </header>\n        <main class=\"medium\">\n            Welcome to my home page!\n        </main>\n        <footer class=\"small\">\n            Copyright &#169; John Harvard\n        </footer>\n    </body>\n</html>\nNotice that style.css is linked to this HTML file as a stylesheet, telling the browser where to locate the styles we created.\n\nFrameworks\nSimilar to third-party libraries we can leverage in Python, there are third-party libraries called frameworks that we can utilize with our HTML files.\nBootstrap is one of these frameworks that we can use to beautify our HTML and easily perfect design elements such that our pages are more readable.\nBootstrap can be utilized by adding the following link tag in the head of your html file:\n\n<head>\n      <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN\" crossorigin=\"anonymous\">\n    <title>favorites</title>\n</head>\nConsider the following HTML:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates table -->\n\n<html lang=\"en\">\n    <head>\n        <title>phonebook</title>\n    </head>\n    <body>\n        <table>\n            <thead>\n                <tr>\n                    <th>Name</th>\n                    <th>Number</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td>Carter</td>\n                    <td>+1-617-495-1000</td>\n                </tr>\n                <tr>\n                    <td>David</td>\n                    <td>+1-617-495-1000</td>\n                </tr>\n                <tr>\n                    <td>John</td>\n                    <td>+1-949-468-2750</td>\n                </tr>\n            </tbody>\n        </table>\n    </body>\n</html>\nNotice how when looking at a served version of this page, it\u2019s quite plain.\n\nNow consider the following HTML that implements the use of Bootstrap:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates table with Bootstrap -->\n\n<html lang=\"en\">\n    <head>\n        <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN\" crossorigin=\"anonymous\">\n        <title>phonebook</title>\n    </head>\n    <body>\n        <table class=\"table\">\n            <thead>\n                <tr>\n                    <th scope=\"col\">Name</th>\n                    <th scope=\"col\">Number</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td>Carter</td>\n                    <td>+1-617-495-1000</td>\n                </tr>\n                <tr>\n                    <td>David</td>\n                    <td>+1-949-468-2750</td>\n                </tr>\n            </tbody>\n        </table>\n    </body>\n</html>\nNotice how much prettier this website is now.\n\nSimilarly, consider to the following expansion of our search page created earlier:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates layout with Bootstrap -->\n\n<html lang=\"en\">\n    <head>\n        <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN\" crossorigin=\"anonymous\">\n        <title>search</title>\n    </head>\n    <body>\n\n        <div class=\"container-fluid\">\n\n            <ul class=\"m-3 nav\">\n                <li class=\"nav-item\">\n                    <a class=\"nav-link text-dark\" href=\"https://about.google/\">About</a>\n                </li>\n                <li class=\"nav-item\">\n                    <a class=\"nav-link text-dark\" href=\"https://store.google.com/\">Store</a>\n                </li>\n                <li class=\"nav-item ms-auto\">\n                    <a class=\"nav-link text-dark\" href=\"https://www.google.com/gmail/\">Gmail</a>\n                </li>\n                <li class=\"nav-item\">\n                    <a class=\"nav-link text-dark\" href=\"https://www.google.com/imghp\">Images</a>\n                </li>\n                <li class=\"nav-item\">\n                    <a class=\"nav-link text-dark\" href=\"https://www.google.com/intl/en/about/products\">\n                        <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-grid-3x3-gap-fill\" viewBox=\"0 0 16 16\">\n                            <path d=\"M1 2a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2zm5 0a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V2zm5 0a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1V2zM1 7a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V7zm5 0a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V7zm5 0a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1V7zM1 12a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1v-2zm5 0a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1v-2zm5 0a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1v-2z\"/>\n                        </svg>\n                    </a>\n                </li>\n                <li class=\"nav-item\">\n                    <a class=\"btn btn-primary\" href=\"https://accounts.google.com/ServiceLogin\" role=\"button\">Sign in</a>\n                </li>\n            </ul>\n\n            <div class=\"text-center\">\n\n                <!-- https://knowyourmeme.com/memes/happy-cat -->\n                <img alt=\"Happy Cat\" class=\"img-fluid w-25\" src=\"cat.gif\">\n\n                <form action=\"https://www.google.com/search\" class=\"mt-4\" method=\"get\">\n                    <input autocomplete=\"off\" autofocus class=\"form-control form-control-lg mb-4 mx-auto w-50\" name=\"q\" placeholder=\"Query\" type=\"search\">\n                    <button class=\"btn btn-light\">Google Search</button>\n                    <button class=\"btn btn-light\" name=\"btnI\">I'm Feeling Lucky</button>\n                </form>\n\n            </div>\n\n        </div>\n\n    </body>\n</html>\nThis version of the page is exceedingly stylized, thanks to Bootstrap.\n\nYou can learn more about this in the Bootstrap Documentation.\nJavaScript\nJavaScript is another programming language that allows for interactivity within web pages.\nConsider the following implemntation of hello.html that includes both JavaScript and HTML:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates onsubmit -->\n\n<html lang=\"en\">\n    <head>\n        <script>\n\n            function greet()\n            {\n                alert('hello, ' + document.querySelector('#name').value);\n            }\n\n        </script>\n        <title>hello</title>\n    </head>\n    <body>\n        <form onsubmit=\"greet(); return false;\">\n            <input autocomplete=\"off\" autofocus id=\"name\" placeholder=\"Name\" type=\"text\">\n            <input type=\"submit\">\n        </form>\n    </body>\n</html>\nNotice how this form uses an onsubmit property to trigger a script found at the top of the file. The script uses alert to create an alert pop-up. #name.value goes to the textbox on the page and obtains the value typed by the user.\n\nGenerally, it\u2019s considered bad design to mix onsubmit and JavaScript. We can advance our code as follows:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates DOMContentLoaded -->\n\n<html lang=\"en\">\n    <head>\n        <script>\n\n            document.addEventListener('DOMContentLoaded', function() {\n                document.querySelector('form').addEventListener('submit', function(e) {\n                    alert('hello, ' + document.querySelector('#name').value);\n                    e.preventDefault();\n                });\n            });\n\n        </script>\n        <title>hello</title>\n    </head>\n    <body>\n        <form>\n            <input autocomplete=\"off\" autofocus id=\"name\" placeholder=\"Name\" type=\"text\">\n            <input type=\"submit\">\n        </form>\n    </body>\n</html>\nNotice that this version of the code creates an addEventListener to listen to the form submit being triggered. Notice how DOMContentLoaded ensures that the whole page is loaded before executing the JavaScript.\n\nJavaScript allows you to dynamically read and modify the html document loaded into memory such that the user need not reload to see changes.\nConsider the following HTML:\n\n<!DOCTYPE html>\n\n<!-- Demonstrates programmatic changes to style -->\n\n<html lang=\"en\">\n    <head>\n        <title>background</title>\n    </head>\n    <body>\n        <button id=\"red\">R</button>\n        <button id=\"green\">G</button>\n        <button id=\"blue\">B</button>\n        <script>\n\n            let body = document.querySelector('body');\n            document.querySelector('#red').addEventListener('click', function() {\n                body.style.backgroundColor = 'red';\n            });\n            document.querySelector('#green').addEventListener('click', function() {\n                body.style.backgroundColor = 'green';\n            });\n            document.querySelector('#blue').addEventListener('click', function() {\n                body.style.backgroundColor = 'blue';\n            });\n\n        </script>\n    </body>\n</html>\nNotice that JavaScript listens for when a specific button is clicked. Upon such a click, certain style attributes on the page are changed. body is defined as the body of the page. Then, an event listener waits for the clicking of one of the buttons. Then, the body.style.backgroundColor is changed.\n\nSimilarly, consider the following:\n\n<!DOCTYPE html>\n\n<html lang=\"en\">\n    <head>\n        <script>\n\n            // Toggles visibility of greeting\n            function blink()\n            {\n                let body = document.querySelector('body');\n                if (body.style.visibility == 'hidden')\n                {\n                    body.style.visibility = 'visible';\n                }\n                else\n                {\n                    body.style.visibility = 'hidden';\n                }\n            }\n\n            // Blink every 500ms\n            window.setInterval(blink, 500);\n\n        </script>\n        <title>blink</title>\n    </head>\n    <body>\n        hello, world\n    </body>\n</html>\nThis example blinks a text at a set interval. Notice that window.setInterval takes in two arguments: A function to be called and a wait period (in milliseconds) between function calls.\n\nConsider the following:\n\n<!DOCTYPE html>\n\n<html lang=\"en\">\n\n    <head>\n        <title>autocomplete</title>\n    </head>\n\n    <body>\n\n        <input autocomplete=\"off\" autofocus placeholder=\"Query\" type=\"text\">\n\n        <ul></ul>\n\n        <script src=\"large.js\"></script>\n        <script>\n      \n            let input = document.querySelector('input');\n            input.addEventListener('keyup', function(event) {\n                let html = '';\n                if (input.value) {\n                    for (word of WORDS) {\n                        if (word.startsWith(input.value)) {\n                            html += `<li>${word}</li>`;\n                        }\n                    }\n                }\n                document.querySelector('ul').innerHTML = html;\n            });\n\n        </script>\n\n    </body>\n</html>\nThis is a JavaScript implementation of autocomplete. This pulls from a file (not pictured here) called large.js that is a list of words.\n\nInterestingly, we can also geolocate using JavaScript:\n\n<!DOCTYPE html>\n\n<html lang=\"en\">\n    <head>\n        <title>geolocation</title>\n    </head>\n    <body>\n        <script>\n          \n            navigator.geolocation.getCurrentPosition(function(position) {\n                document.write(position.coords.latitude + \", \" + position.coords.longitude);\n            });\n\n        </script>\n    </body>\n</html>\nNotice that navigator.geolocation is used to getCurrentPosition. This will not work if your computer or browser does not allow for location tracking.\n\nThe capabilities of JavaScript are many and can be found in the JavaScript Documentation.\nSumming Up\nIn this lesson, you learned how to create your own HTML files, style them, leverage third-party frameworks, and utilize JavaScript. Specifically, we discussed\u2026\n\nTCP/IP\nDNS\nHTML\nRegular expressions.\nCSS\nFrameworks\nJavaScript\nSee you next time!"
        }
    ],
    "extra": []
}